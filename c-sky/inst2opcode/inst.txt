

    
    
  



  
    


























































































     
   

     
   













  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  








  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  

  
  
  
  
  

  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  

  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  

  
  
  
  

  
  

  
  
  
  
  

  
  

  

  
  
  
  

  
  
  

  
  

  
  
  
  
  
  
  





       
   
   

             
     
     

                
      
      

                   
       
       

       
   
   

             
     
     

             
     
     

             
     
     

             
     
     

             
     
     

                
      
      

                   
       
       

                   
       
       

                   
       
       

                   
       
       

                   
       
       

                   
       
       

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    





  
  
  
  
  
  

  
  
  
  
  
  

  
  
  
  
  
  
  
  

  
  
  

  
  
  
  

  
  
  
  
  
  

  
  





       
   
   

           
     
     

            
     
     

            
     
     

       
   
   

           
     
     

           
     
     

            
     
     

            
     
     

            
     
     

            
     
     

            
     
     

            
     
     

4. 指令术语表 
以下是每条CSKY V2指令的具体描述，下面根据指令英文字母顺序对每条指令进行详细说明。 
4.1. 32位指令 
以下是CSKY V2中32位指令的具体描述，带＊为伪指令。 
 
ABS――绝对值指令 
 
操作： 
 RZ ← |RX| 
 
yufa:
 abs  rz, rx 
 
说明： 
 取RX值的绝对值，并把结果存在RZ。 
注意，操作数0x80000000的结果为80000000。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000000 
 10000 
 00000 
 

ADDC――无符号带进位加法指令 
 
操作： 
 RZ ← RX+RY+C，C←进位 
 
yufa:
 addc  rz, rx, ry 
 
说明： 
 将RX、RY与C位的值相加，并把结果存在RZ，进位存在C位。 
 
影响标志位： 
 C ← 进位 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000000 
 00010 
 RY 
 

ADDI――无符号立即数加法指令 
 
操作： 
 RZ ← RX + zero_extend(OIMM16) 
 
yufa:
 addi  rz, rx, oimm16 
 
说明： 
 将带偏置1的16位立即数（OIMM16）零扩展至32位，然后与RX的值相加，把结果存入RZ。 
注意：二进制操作数IMM16等于OIMM16 - 1。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0x1-0x10000。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 01000 
 RZ 
 RX 
 IMM16 
 

 
IMM16域――指定不带偏置立即数的值。 
注意：加到寄存器里的值OIMM16比起二进制操作数IMM16需偏置1。 
0000000000000000――加0x1 
0000000000000001――加0x2 
…… 
1111111111111111――加0x10000 
 
ADDU――无符号加法指令 
 
操作： 
 RZ ← RX+RY 
 
yufa:
 addu  rz, rx, ry 
 
说明： 
 将RX与RY的值相加，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000000 
 00001 
 RY 
 

AND――按位与指令 
 
操作： 
 RZ ← RX & RY 
 
yufa:
 and  rz, rx, ry 
 
说明： 
 将RX与RY的值按位与，并把结果存在RZ。 
 

 
 
ANDI――立即数按位与指令 
 
操作： 
 RZ ← RX & zero_extend(IMM16) 
 
yufa:
 andi  rz, rx, imm16 
 
说明： 
 将16位立即数零扩展至32位，然后与RX的值进行按位与操作，把结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0x0-0xFFFF。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 01010 
 RZ 
 RX 
 IMM16 
 

ANDN――按位非与指令 
 
操作： 
 RZ ← RX & (!RY) 
 
yufa:
 andn  rz, rx, ry 
 
说明： 
 将RX的值与RY的非值按位与，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 001000 
 00010 
 RY 
 

ANDNI――立即数按位非与指令 
 
操作： 
 RZ ← RX & !(zero_extend(IMM16)) 
 
yufa:
 andni  rz, rx, imm16 
 
说明： 
 将16位立即数零扩展至32位并取非，然后与RX的值进行按位与操作，把结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0x0-0xFFFF。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 01011 
 RZ 
 RX 
 IMM16 
 

ASR――算术右移指令 
 
操作： 
 RZ ← RX >>> RY[5:0] 
 
yufa:
 asr  rz, rx, ry 
 
说明： 
 将RX的值进行算术右移（原值右移，左侧移入原符号位的拷贝），结果存入RZ，右移位数由RY低6位（RY[5:0]）的值决定；如果RY[5:0]的值大于30，那么RZ的值（0或-1）由RX的符号位决定。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010000 
 00100 
 RY 
 

 
ASRC――立即数算术右移至C位指令 
 
操作： 
 RZ ← RX >>> OIMM5, C ← RX[OIMM5 - 1] 
 
yufa:
 asrc  rz, rx, oimm5 
 
说明： 
 将RX的值进行算术右移（原值右移，左侧移入原符号位的拷贝），把移出最末位存入条件位C，移位结果存入RZ，右移位数由带偏置1的5位立即数（OIMM5）的值决定。如果OIMM5的值等于32，那么条件位C为RX的符号位（最高位），RZ的值（0或-1）由RX的符号位决定。 
注意：二进制操作数IMM5等于OIMM5 - 1。 
 
影响标志位： 
 C ← RX[OIMM5 - 1] 
 
限制： 
 立即数的范围为1-32。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010011 
 00100 
 IMM5 
 

 
IMM5域――指定不带偏置立即数的值。 
注意：移位的值OIMM5比起二进制操作数IMM5需偏置1。 
00000――移1位 
00001――移2位 
…… 
11111――移32位 
ASRI――立即数算术右移指令 
 
操作： 
 RZ ← RX >>> IMM5 
 
yufa:
 asri  rz, rx, imm5 
 
说明： 
 将RX的值进行算术右移（原值右移，左侧移入原符号位的拷贝），结果存入RZ，右移位数由5位立即数（IMM5）的值决定；如果IMM5的值等于0，那么RZ的值将与RX相同。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010010 
 00100 
 IMM5 
 

 
BCLRI――立即数位清零指令 
 
操作： 
 RZ ← RX[IMM5]清零 
 
yufa:
 bclri  rz, rx, imm5 
 
说明： 
 将RX的值中，由IMM5域值所指示的位清零，其余位保持不变，把清零后的结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 001010 
 00001 
 00000 
 

BE――寄存器相等分支指令 
 
操作： 
 寄存器比较相等则程序转移 
if(RX == RY) 
  PC . PC + sign_extend(offset << 1) 
else 
  PC. PC + 4 
 
yufa:
 be  rx, ry, label 
 
说明： 
 如果寄存器RX与寄存器RY相等，则程序转移到label处执行；否则程序执行下一条指令，即PC . PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BE指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00010 
 RY 
 RX 
 IMM16 
 

 
BEZ――寄存器等于零分支指令 
 
操作： 
 寄存器等于零则程序转移 
if(RX == 0) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 4 
 
yufa:
 bez  rx, label 
 
说明： 
 如果寄存器RX等于零，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BEZ指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 00000 
 RX 
 Offset 
 

BF――C为0分支指令 
 
操作： 
 C等于零则程序转移 
if(C == 0) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC← PC + 4 
 
yufa:
 bf  label 
 
说明： 
 如果条件标志位C等于零，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BF指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 10000 
 00000 
 Offset 
 

BGENI――立即数位产生指令* 
 
操作： 
 RZ ←（2）IMM5; 
 
yufa:
 bgeni  rz, imm5 
 
说明： 
 对由5位立即数确定的RX位（RZ[IMM5]）置位，并清除RX的其它位。 
注意，如果IMM5小于16，该指令是movi  rz, (2)IMM5的伪指令；如果IMM5大于等于16，该指令是movih  rz, (2)IMM5的伪指令。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
如果IMM5小于16： 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00111 
 00000 
 RZ 
 （2）IMM5 
 

 
如果IMM5大于等于16： 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00111 
 00001 
 RZ 
 （2）IMM5 
 

BGENR――寄存器位产生指令 
 
操作： 
 If (RX[5] == 0) ，then 
RZ ← 2RX[4:0]; 
else 
  RZ ← 0; 
 
yufa:
 bgenr  rz, rx 
 
说明： 
 如果RX[5]为0，那么置RZ由RX低五位（RX[4:0]）确定的寄存器位，并清除RZ所有其它的位；否则，对RZ清零。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 001010 
 10000 
 00000 
 

BHSZ――寄存器大于等于零分支指令 
 
操作： 
 寄存器大于等于零则程序转移 
if(RX >= 0) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 4 
 
yufa:
 bhsz  rx, label 
 
说明： 
 如果寄存器RX大于或等于零，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BHSZ指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 00101 
 RX 
 Offset 
 

BHZ――寄存器大于零分支指令 
 
操作： 
 寄存器大于零则程序转移 
if(RX > 0) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 4 
 
yufa:
 bhz  rx, label 
 
说明： 
 如果寄存器RX大于零，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BHZ指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 00010 
 RX 
 Offset 
 

BKPT――断点指令 
 
操作： 
 引起一个断点异常或者进入调试模式 
 
yufa:
 bkpt 
 
说明： 
 断点指令 
 
影响标志位： 
 无影响 
 
异常： 
 断点异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 000000 
 00001 
 00000 
 

BLSZ――寄存器小于等于零分支指令 
 
操作： 
 寄存器小于等于零则程序转移 
if(RX <= 0) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 4 
 
yufa:
 blsz  rx, label 
 
说明： 
 如果寄存器RX小于或等于零，则程序转移到label处执行；否则程序执行下一条指令，即PC . PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BLSZ指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 00011 
 RX 
 Offset 
 

BLZ――寄存器小于零分支指令 
 
操作： 
 寄存器小于零则程序转移 
if(RX < 0) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 4 
 
yufa:
 blz  rx, label 
 
说明： 
 如果寄存器RX小于零，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BLZ指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 00100 
 RX 
 Offset 
 

BMASKI――立即数位屏蔽产生指令 
 
操作： 
 RZ ← (2)IMM5 + 1 - 1 
 
yufa:
 bmaski  rz, imm5 
 
说明： 
 产生连续低位为1、高位为0的立即数，并将该立即数存入RZ。IMM5域指定被置1的连续位（RX[IMM5:0]）的最高位，其余高位清零。 
注意，IMM5为0-15时由movi指令执行。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为16-31； 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 00000 
 001010 
 01000 
 IMM5 
 

 
IMM5域――指定被置1的连续低位位数。 
10000――0-16位置位 
10001――0-17位置位 
…… 
11111――0-31位置位 
BNE――寄存器不等分支指令 
 
操作： 
 寄存器比较不相等则程序转移 
if(RX != RY) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 4 
 
yufa:
 bne  rx, ry, label 
 
说明： 
 如果寄存器RX与寄存器RY不相等，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BNE指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00011 
 RY 
 RX 
 Offset 
 

BNEZ――寄存器不等于零分支指令 
 
操作： 
 寄存器不等于零则程序转移 
if(RX != 0) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 4 
 
yufa:
 bnez  rx, label 
 
说明： 
 如果寄存器RX不等于零，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BNEZ指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 00001 
 RX 
 Offset 
 

BR――无条件跳转指令 
 
操作： 
 PC ← PC + sign_extend(offset << 1) 
 
yufa:
 br  label 
 
说明： 
 程序无条件跳转到label处执行。 
Label由当前程序PC加上左移1位的26位相对偏移量有符号扩展到32位后的值得到。BR指令的跳转范围是±64MB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 0 
 
0 
 00000 
 Offset 
 

BREV――位倒序指令 
 
操作： 
 for i=0 to 31 
RZ[i] ← RX[31-i]; 
 
yufa:
 brev  rz, rx 
 
说明： 
 把RX的值按位取倒序，结果存入RZ。 
如果RX的值为”abcdefghijklmnopqrstuvwxyz012345”，按位取倒序后，RZ的值变为”543210zyxwvutsrqponmlkjihgfedcba”。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 011000 
 10000 
 00000 
 

BSETI――立即数位置位指令 
 
操作： 
 RZ ← RX[IMM5]置位 
 
yufa:
 bseti  rz, rx, imm5 
 
说明： 
 将RX的值中，由IMM5域值所指示的位置1，其余位保持不变，把置位后的结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 001010 
 00010 
 IMM5 
 

BSR――跳转到子程序指令 
 
操作： 
 链接并跳转到子程序： 
R31 ← PC+4 
PC ← PC + sign_extend(offset << 1) 
 
yufa:
 bsr  label 
 
说明： 
 子程序跳转，将子程序的返回地址（下一条指令的PC，即当前PC+4）保存在链接寄存器R31中，程序转移到label处执行。 
Label由当前程序PC加上左移1位的26位相对偏移量有符号扩展到32位后的值得到。BSR指令的跳转范围是±64MB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 0 
 
0 
 00001 
 Offset 
 

BT――C为1分支指令 
 
操作： 
 C等于一则程序转移 
if(C == 1) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 4 
 
yufa:
 bt  label 
 
说明： 
 如果条件标志位C等于1，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 4。 
Label由当前程序PC加上左移1位的16位相对偏移量有符号扩展到32位后的值得到。BT指令的转移范围是±64KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 10001 
 00000 
 Offset 
 

BTSTI――立即数位测试指令 
 
操作： 
 C ← RX[IMM5] 
 
yufa:
 btsti  rx, imm5 
 
说明： 
 对由IMM5决定的RX的位（RX[IMM5]）进行测试，并使条件位C的值等于该位的值。 
 
影响标志位： 
 C ← RX[IMM5] 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 001010 
 00100 
 IMM5 
 

CLRF――C为0清零指令 
 
操作： 
 if C==0, then 
RZ ← 0; 
else 
  RZ ← RZ; 
 
yufa:
 clrt  rz 
 
说明： 
 如果C为0，寄存器RZ被清零；否则，寄存器RZ保持不变。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 00000 
 001011 
 00001 
 00000 
 

CLRT――C为1清零指令 
 
操作： 
 if C==1, then 
RZ ← 0; 
else 
  RZ ← RZ; 
 
yufa:
 clrt  rz 
 
说明： 
 如果C为1，寄存器RZ被清零；否则，寄存器RZ保持不变。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 00000 
 001011 
 00010 
 00000 
 

CMPHS――无符号大于等于比较指令 
 
操作： 
 RX与RY作无符号比较。 
If RX >= RY, then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmphs  rx, ry 
 
说明： 
 将RX的值减去RY的值，结果与0作比较，并对C位进行更新。cmphs进行无符号比较，即操作数被认为是无符号数。如果RX大于等于RY，即减法结果大于等于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 000001 
 00001 
 RY 
 

CMPHSI――立即数无符号大于等于比较指令 
 
操作： 
 RX与立即数作无符号比较。 
If RX >= zero_extend(OIMM16), then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmphsi  rx, oimm16 
 
说明： 
 将带偏置1的16位立即数（OIMM16）零扩展至32位，然后用RX的值减去该32位值，结果与0作比较，并对C位进行更新。cmphsi进行无符号比较，即操作数被认为是无符号数。如果RX大于等于零扩展后的OIMM16，即减法结果大于等于0，则设置条件位C；否则，清除条件位C。 
注意：二进制操作数IMM16等于OIMM16 - 1。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
限制： 
 立即数的范围为0x1-0x10000。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00111 
 10000 
 RX 
 IMM16 
 

 
IMM16域――指定不带偏置立即数的值。 
注意：参与比较的立即数OIMM16比起二进制操作数IMM16需偏置1。 
0000000000000000――与0x1比较 
0000000000000001――与0x2比较 
…… 
1111111111111111――与0x10000比较 
CMPLT――有符号小于比较指令 
 
操作： 
 RX与RY作有符号比较。 
If RX < RY, then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmplt  rx, ry 
 
说明： 
 将RX的值减去RY的值，结果与0作比较，并对C位进行更新。cmplt进行有符号比较，即操作数被认为是补码形式的有符号数。如果RX小于RY，即减法结果小于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 000001 
 00010 
 RY 
 

CMPLTI――立即数有符号小于比较指令 
 
操作： 
 RX与立即数作有符号比较。 
If RX < zero_extend(OIMM16), then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmplti  rx, oimm16 
 
说明： 
 将带偏置1的16位立即数（OIMM16）零扩展至32位，然后用RX的值减去该32位值，结果与0作比较，并对C位进行更新。cmplti进行有符号比较，即RX的值被认为是补码形式的有符号数。如果RX小于零扩展后的OIMM16，即减法结果小于0，则设置条件位C；否则，清除条件位C。 
注意：二进制操作数IMM16等于OIMM16 - 1。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
限制： 
 立即数的范围为0x1-0x10000。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00111 
 10001 
 RX 
 IMM16 
 

 
IMM16域――指定不带偏置立即数的值。 
注意：参与比较的立即数OIMM16比起二进制操作数IMM16需偏置1。 
0000000000000000――与0x1比较 
0000000000000001――与0x2比较 
…… 
1111111111111111――与0x10000比较 
 
CMPNE――不等比较指令 
 
操作： 
 RX与RY作比较。 
If RX != RY, then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmpne  rx, ry 
 
说明： 
 将RX的值减去RY的值，结果与0作比较，并对C位进行更新。如果RX不等于RY，即减法结果不等于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 000001 
 00100 
 RY 
 

CMPNEI――立即数不等比较指令 
 
操作： 
 RX与立即数作比较。 
If RX != zero_extend(imm16), then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmpnei  rx, imm16 
 
说明： 
 将RX的值减去零扩展至32位的16位立即数的值，结果与0作比较，并对C位进行更新。如果RX不等于零扩展后的IMM16，即减法结果不等于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
限制： 
 立即数的范围为0x0-0xFFFF。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00111 
 10010 
 RX 
 IMM16 
 

CPOP――协处理器操作指令 
 
操作： 
 协处理器操作指令，执行一个或多个用户自定义的协处理器操作。 
 
yufa:
 cpop  <cpid, func> 
 
说明： 
 该指令执行由用户自定义的协处理器操作。指令低26位编码空间预留给用户自定义使用，其中第22~25位约定为协处理器号，用于指定预操作的协处理器，其余位由用户自定义相关操作（如可用作协处理器指令码的传输）。 
 
影响标志位： 
 该协处理器操作指令不影响主流水线标志位，但可能影响协处理器的标志位。 
 
异常： 
 非法指令异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 0 
 
0 
 11000 
 User-define 
 

CPRC――协处理器条件位读传送指令 
 
操作： 
 读取协处理器的条件位至主处理器的C位，协处理器号由用户自定义。 
 
yufa:
 cprc  <cpid, func> 
 
说明： 
 该指令执行由用户自定义的协处理器条件位读取操作。指令低16位编码空间预留给用户自定义使用，其中第12~15位约定为协处理器号，用于指定预操作的协处理器，其余位由用户自定义相关操作。 
 
影响标志位： 
 主流水线的标志位由指定的协处理器的条件位决定。 
 
异常： 
 非法指令异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 11001 
 10000 
 00000 
 User-define 
 

CPRCR――协处理器控制寄存器读传送指令 
 
操作： 
 读取协处理器的控制寄存器至主处理器的通用寄存器中，协处理器号和协处理器控制寄存器号由用户自定义。 
 
yufa:
 cprcr  rz, <cpid, func> 
 
说明： 
 该指令执行由用户自定义的协处理器控制寄存器读取操作。指令低16位编码空间预留给用户自定义使用，其中第12~15位约定为协处理器号，用于指定预操作的协处理器，其余位由用户自定义协处理器控制寄存器号及相关操作。 
 
影响标志位： 
 不影响 
 
异常： 
 非法指令异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 11001 
 00010 
 RZ 
 User-define 
 

CPRGR――协处理器通用寄存器读传送指令 
 
操作： 
 读取协处理器的通用寄存器至主处理器的通用寄存器中，协处理器号和协处理器通用寄存器号由用户自定义。 
 
yufa:
 cprgr  rz, <cpid, func> 
 
说明： 
 该指令执行由用户自定义的协处理器通用寄存器读取操作。指令低16位编码空间预留给用户自定义使用，其中第12~15位约定为协处理器号，用于指定预操作的协处理器，其余位由用户自定义协处理器通用寄存器号及相关操作。 
 
影响标志位： 
 不影响 
 
异常： 
 非法指令异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 11001 
 00000 
 RZ 
 User-define 
 

CPWCR――协处理器控制寄存器写传送指令 
 
操作： 
 将主处理器通用寄存器中的内容写入到协处理器的控制寄存器，协处理器号和协处理器控制寄存器号由用户自定义。 
 
yufa:
 cpwcr  rx, <cpid, func> 
 
说明： 
 该指令执行由用户自定义的协处理器控制寄存器写入操作。指令低16位编码空间预留给用户自定义使用，其中第12~15位约定为协处理器号，用于指定预操作的协处理器，其余位由用户自定义协处理器控制寄存器号及相关操作。 
 
影响标志位： 
 不影响 
 
异常： 
 非法指令异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 11001 
 00001 
 RX 
 User-define 
 

CPWGR――协处理器通用寄存器写传送指令 
 
操作： 
 将主处理器通用寄存器中的内容写入到协处理器的通用寄存器，协处理器号和协处理器通用寄存器号由用户自定义。 
 
yufa:
 cpwgr  rx, <cpid, func> 
 
说明： 
 该指令执行由用户自定义的协处理器通用寄存器写入操作。指令低16位编码空间预留给用户自定义使用，其中第12~15位约定为协处理器号，用于指定预操作的协处理器，其余位由用户自定义协处理器通用寄存器号及相关操作。 
 
影响标志位： 
 不影响 
 
异常： 
 非法指令异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 11001 
 00011 
 RX 
 User-define 
 

DECF――C为0立即数减法指令 
 
操作： 
 if C==0, then 
RZ ← RX - zero_extend(IMM5); 
else 
  RZ ← RZ; 
 
yufa:
 decf  rz, rx, imm5 
 
说明： 
 如果条件位C为0，将5位立即数零扩展至32位，用RX的值减去该32位值，把结果存在RZ；否则，RZ与RX的值不变。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000011 
 00100 
 IMM5 
 

DECGT――减法大于零置C位指令 
 
操作： 
 RZ ← RX - zero_extend(IMM5); 
If RZ > 0, then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 decgt  rz, rx, imm5 
 
说明： 
 将5位立即数零扩展至32位，把RX减去该32位值的结果存在RZ。减法结果被认为是补码形式的有符号数。如果结果大于0，设置条件位C；否则清除条件位C。 
 
影响标志位： 
 如果减法结果大于0，设置条件位C；否则清除条件位C。 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000100 
 00001 
 IMM5 
 

DECLT――减法小于零置C位指令 
 
操作： 
 RZ ← RX - zero_extend(IMM5); 
If RZ < 0, then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 declt  rz, rx, imm5 
 
说明： 
 将5位立即数零扩展至32位，把RX减去该32位值的结果存在RZ。减法结果被认为是补码形式的有符号数。如果结果小于0，设置条件位C；否则清除条件位C。 
 
影响标志位： 
 如果减法结果小于0，设置条件位C；否则清除条件位C。 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000100 
 00010 
 IMM5 
 

DECNE――减法不等于零置C位指令 
 
操作： 
 RZ ← RX - zero_extend(IMM5); 
If RZ != 0, then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 decne  rz, rx, imm5 
 
说明： 
 将16位立即数零扩展至32位，把RX减去该32位值的结果存在RZ。如果结果不等于0，设置条件位C；否则清除条件位C。 
 
影响标志位： 
 如果减法结果不等于0，设置条件位C；否则清除条件位C。 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000100 
 00100 
 IMM5 
 

DECT――C为1立即数减法指令 
 
操作： 
 if C==1, then 
RZ ← RX - zero_extend(IMM5); 
else 
  RZ ← RZ; 
 
yufa:
 dect  rz, rx, imm5 
 
说明： 
 如果条件位C为1，将5位立即数零扩展至32位，用RX的值减去该32位值，把结果存在RZ；否则，RZ与RX的值不变。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000011 
 01000 
 IMM5 
 

DIVS――有符号除法指令 
 
操作： 
 有符号除法 
RZ = RX / RY 
 
yufa:
 divs  rz, rx, ry 
 
说明： 
 有符号寄存器除法指令将寄存器RX的值除以寄存器RY的值，得到的商存放于RZ中。RX、RY和RZ的值均被认为是32位有符号数。 
 
影响标志位： 
 不影响 
 
异常： 
 除零异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 100000 
 00010 
 RY 
 

 
DIVU――无符号除法指令 
 
操作： 
 无符号除法 
RZ = RX/RY 
 
yufa:
 divu  rz, rx, ry 
 
说明： 
 无符号寄存器除法指令将寄存器RX的值除以寄存器RY的值，得到的商存放于RZ中。RX、RY和RZ的值均被认为是32位无符号数。 
 
影响标志位： 
 不影响 
 
异常： 
 除零异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 100000 
 00001 
 RY 
 

DOZE――进入低功耗睡眠模式指令 
 
操作： 
 进入低功耗睡眠模式 
 
yufa:
 doze 
 
属性： 
 特权指令 
 
说明： 
 此指令使处理器进入低功耗睡眠模式，并等待一个中断来退出这个模式。此时，CPU时钟停止，相应的外围设备也被停止。 
 
影响标志位： 
 不影响 
 
异常： 
 特权违反异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 010100 
 00001 
 00000 
 

FF1――快速找1指令 
 
操作： 
 RZ ← find_first_1(RX); 
 
yufa:
 ff1  rz, rx 
 
说明： 
 查找RX第一个为1的位，并把查找结果返回到RZ。查找顺序是从RX的最高位扫描到最低位。如果RX的最高位（RX[31]）为1，返回RZ的值为0。如果在RX没有为1的位，返回RZ的值为32。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 011111 
 00010 
 00000 
 

INCF――C为0立即数加法指令 
 
操作： 
 if C==0, then 
RZ ← RX + zero_extend(IMM5); 
else 
  RZ ← RZ; 
 
yufa:
 incf  rz, rx, imm5 
 
说明： 
 如果条件位C为0，将5位立即数零扩展至32位，用该32位值加RX的值，把结果存在RZ；否则，RZ与RX的值不变。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000011 
 00001 
 IMM5 
 

INCT――C为1立即数加法指令 
 
操作： 
 if C==1, then 
RZ ← RX + zero_extend(IMM5); 
else 
  RZ ← RZ; 
 
yufa:
 inct  rz, rx, imm5 
 
说明： 
 如果条件位C为0，将5位立即数零扩展至32位，用该32位值加RX的值，把结果存在RZ；否则，RZ与RX的值不变。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000011 
 00010 
 IMM5 
 

INS――位插入指令 
 
操作： 
 RZ[MSB:LSB] ← RX[MSB-LSB:0] 
 
yufa:
 ins  rz, rx, msb, lsb 
 
说明： 
 将RX的一段连续低位，插入到由2个5位立即数（MSB,LSB）指定的RZ的一段连续位（RZ[MSB:LSB]）上，RZ的其它位保持不变，RX连续低位的宽度由MSB和LSB指定（即RX[MSB-LSB:0]）。如果MSB等于31，且LSB等于0，则RZ的值与RX相同。如果MSB等于LSB，则RZ的MSB（即LSB）位为RX的最低位，其它位保持不变。如果MSB小于LSB，该指令的行为不可预测。 
注意：二进制操作数SIZE等于MSB-LSB+1。 
 
影响标志位： 
 无影响 
 
限制： 
 MSB的范围为0-31，LSB的范围为0-31，且MSB应当大于等于LSB。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010111 
 MSB 
 SIZE 
 

 
MSB域――指定插入起始的位置。 
00000――0 
00001――1 
…… 
11111――31 
 
SIZE域――指定被插入位的宽度。 
注意：二进制操作数SIZE等于MSB-LSB+1，SIZE应当大于等于0，且小于等于32-MSB。 
00000――0 
00001――1 
…… 
11111――31 
 
IXH――索引半字指令 
 
操作： 
 RZ ← RX + (RY << 1) 
 
yufa:
 ixh  rz, rx,ry 
 
说明： 
 将RY的值左移一位后加上RX的值，并把结果存入RZ。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000010 
 00001 
 RY 
 

IXW――索引字指令 
 
操作： 
 RX ← RX + (RY << 2) 
 
yufa:
 ixw  rz, rx, ry 
 
说明： 
 将RY的值左移两位后加上RX的值，并把结果存入RZ。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000010 
 00010 
 RY 
 

JMP――寄存器跳转指令 
 
操作： 
 跳转到寄存器指定的位置 
PC ← RX & 0xfffffffe 
 
yufa:
 jmp  rx 
 
说明： 
 程序跳转到寄存器RX指定的位置，RX的最低位被忽略。JMP指令的跳转范围是全部4GB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 RX 
 100000 
 00001 
 00000 
 

JMPI――间接跳转指令 
 
操作： 
 程序跳转到存储器指定的位置 
PC ← MEM[(PC + unsign_extend(offset << 2)) & 0xfffffffc] 
 
yufa:
 jmpi  label 
 
说明： 
 程序跳转到label所在的位置，label由存储器加载得到。存储器地址根据PC加上左移两位的16位相对偏移量无符号扩展到32位后，再经最低两位强制清零得到。JMPI指令的跳转范围是全部4GB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 11000 
 00000 
 Offset 
 

JMPLR――子程序返回指令* 
 
操作： 
 程序跳转到链接寄存器指定的位置 
PC ← R31 & 0xfffffffe 
 
yufa:
 jmplr 
 
说明： 
 程序跳转到链接寄存器R31指定的位置，链接寄存器的最低位被忽略。JMPLR指令的跳转范围是全部4GB地址空间。 
该指令用于实现子程序返回功能。 
注意，该指令是JMP r31的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 11111 
 100000 
 00001 
 00000 
 

JSR――寄存器跳转到子程序指令 
 
操作： 
 链接并跳转到寄存器指定的子程序位置 
R31 ← PC + 4，PC ← RX & 0xfffffffe 
 
yufa:
 jsr  rx 
 
说明： 
 子程序寄存器跳转，将子程序的返回地址（下一条指令的PC，即当前PC+4）保存在链接寄存器R31中，程序跳转到寄存器RX的内容指定的子程序位置处执行，RX的最低位被忽略。JSR指令的跳转范围是全部4GB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 RX 
 100001 
 00001 
 00000 
 

 
JSRI――间接跳转到子程序指令 
 
操作： 
 程序跳转到存储器指定的子程序位置 
R31 ← PC + 4，PC ← MEM[(PC + unsign_extend(offset << 2)) & 0xfffffffc] 
 
yufa:
 jsri  label 
 
说明： 
 子程序间接跳转，将子程序的返回地址（下一条指令的PC，即当前PC+4）保存在链接寄存器R31中，程序跳转到label所在的位置处执行，label由存储器加载得到。存储器地址根据PC加上左移两位的16位相对偏移量无符号扩展到32位后，再经最低两位强制清零得到。JSRI指令的跳转范围是全部4GB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00100 
 11001 
 00000 
 Offset 
 

 
LD.B――无符号扩展字节加载指令 
 
操作： 
 从存储器加载字节到寄存器，无符号扩展 
RZ ← zero_extend(MEM[RX + zero_extend(offset)]) 
 
yufa:
 ld.b  rz, (rx, offset) 
 
说明： 
 从存储器加载的字节经零扩展到32位后存放于寄存器RZ中。采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上12位相对偏移量无符号扩展到32位后的值得到。LD.B指令可以寻址+4KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10110 
 RZ 
 RX 
 0000 
 Offset 
 

LD.BS――有符号扩展字节加载指令 
 
操作： 
 从存储器加载字节到寄存器，有符号扩展 
RZ ← sign_extend(MEM[RX + zero_extend(offset)]) 
 
yufa:
 ld.bs  rz, (rx, offset) 
 
说明： 
 从存储器加载的字节经有符号扩展到32位后存放于寄存器RZ中。采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上12位相对偏移量无符号扩展到32位后的值得到。LD.BS指令可以寻址+4KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10110 
 RZ 
 RX 
 0100 
 Offset 
 

 
LD.H――无符号扩展半字加载指令 
 
操作： 
 从存储器加载半字到寄存器，无符号扩展 
RZ ← zero_extend(MEM[RX + zero_extend(offset << 1)]) 
 
yufa:
 ld.h  rz, (rx, offset) 
 
说明： 
 从存储器加载的半字经零扩展到32位后存放于寄存器RZ中。采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移1位的12位相对偏移量无符号扩展到32位后的值得到。LD.H指令可以寻址+8KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10110 
 RZ 
 RX 
 0001 
 Offset 
 

LD.HS――有符号扩展半字加载指令 
 
操作： 
 从存储器加载半字到寄存器，有符号扩展 
RZ ← sign_extend(MEM[RX + zero_extend(offset << 1)]) 
 
yufa:
 ld.hs  rz, (rx, offset) 
 
说明： 
 从存储器加载的半字经有符号扩展到32位后存放于寄存器RZ中。采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移1位的12位相对偏移量无符号扩展到32位后的值得到。LD.HS指令可以寻址+8KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10110 
 RZ 
 RX 
 0101 
 Offset 
 

 
LD.W――字加载指令 
 
操作： 
 从存储器加载字到寄存器 
RZ ← MEM[RX + zero_extend(offset << 2)] 
 
yufa:
 ld.w  rz, (rx, offset) 
 
说明： 
 从存储器加载字到寄存器RZ中。采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移两位的12位相对偏移量无符号扩展到32位后的值得到。LD.W指令可以寻址+16KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10110 
 RZ 
 RX 
 0010 
 Offset 
 

LDCPR――协处理器字加载指令 
 
操作： 
 从存储器加载字到协处理器通用寄存器 
CPRZ ← MEM[RX + zero_extend(offset << 2)] 
 
yufa:
 ldcpr  <cpid, cprz>, (rx, offset) 
 
说明： 
 从存储器加载字到协处理器的通用寄存器CPRZ中。采用寄存器加立即数偏移量的寻址方式。指令低12位编码空间中8~11位约定为协处理器号，用于指定预操作的协处理器，其余8位为相对偏移量。存储器的有效地址由主流水线基址寄存器RX加上左移两位的8位相对偏移量无符号扩展到32位后的值得到。LDCPR指令可以寻址+1KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 11010 
 CPRZ 
 RX 
 0000 
 User-define 
 

LDEX.W――独占式字加载指令 
 
操作： 
 从存储器加载字到通用寄存器 
RZ ← MEM[RX + zero_extend(offset << 2)] 
 
yufa:
 ldex.w  rz, (rx, offset) 
 
说明： 
 从存储器加载字到通用寄存器RZ中。采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移两位的12位相对偏移量无符号扩展到32位后的值得到。LDEX.W指令可以寻址+16KB地址空间。 
该指令与STEX.W配对，用于多核通信时的原子“读存储器―修改―写存储器”操作。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10110 
 RZ 
 RX 
 0111 
 Offset 
 

LDM――连续多字加载指令 
 
操作： 
 从存储器加载连续的多个字到一片连续的寄存器堆中 
dst ← Z C IMM5; addr ← RX; 
for (n = 0; n <= IMM5; n++){ 
  Rdst ← MEM[addr]; 
  dst ← dst + 1; 
  addr ← addr + 4; 
} 
 
yufa:
 ldm  ry-rz, (rx) 
 
说明： 
 从存储器依次加载连续的多个字到寄存器RY开始的一片连续寄存器堆中，即将存储器指定地址开始的第一个字加载到寄存器RY中，第二个字加载到寄存器RY+1中，依次类推，最后一个字加载到寄存器RZ中。存储器的有效地址由基址寄存器RX的内容决定。 
 
影响标志位： 
 无影响 
 
限制： 
 RY-RZ范围内不应该包含基址寄存器RX，否则结果不可预测。 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000111 
 00001 
 IMM5 
 

 
IMM5域――指定目标寄存器的个数，IMM5 = Z - Y。 
00000――1个目的寄存器 
00001――2个目的寄存器 
…… 
11111――32个目的寄存器 
LDQ――连续四字加载指令* 
 
操作： 
 从存储器加载连续的四个字到寄存器R4―R7中 
dst ← 4; addr ← RX; 
for (n = 0; n <= 3; n++){ 
  Rdst ← MEM[addr]; 
  dst ← dst + 1; 
  addr ← addr + 4; 
} 
 
yufa:
 ldq  r4-r7, (rx) 
 
说明： 
 从存储器依次加载连续的4个字到寄存器堆[R4, R7]（包括边界）中，即将存储器指定地址开始的第一个字加载到寄存器R4中，第二个字加载到寄存器R5中，第三个字加载到寄存器R6中，第四个字加载到寄存器R7中。存储器的有效地址由基址寄存器RX的内容决定。 
注意，该指令是ldm r4-r7, (rx)的伪指令。 
 
影响标志位： 
 无影响 
 
限制： 
 R4-R7范围内不应该包含基址寄存器RX，否则结果不可预测。 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 00100 
 RX 
 000111 
 00001 
 00011 
 

 
LDR.B――寄存器移位寻址无符号扩展字节加载指令 
 
操作： 
 从存储器加载字节到寄存器，无符号扩展 
RZ ← zero_extend(MEM[RX + RY << IMM2]) 
 
yufa:
 ldr.b  rz, (rx, ry << #0) 
ldr.b  rz, (rx, ry << #1) 
ldr.b  rz, (rx, ry << #2) 
ldr.b  rz, (rx, ry << #3) 
 
说明： 
 从存储器加载的字节经零扩展到32位后存放于寄存器RZ中。采用寄存器加寄存器移位的寻址方式。存储器的有效地址由基址寄存器RX加上偏移量寄存器RY左移2位立即数IMM2后的值得到。IMM2的缺省值为0。 
 
影响标志位： 
 无影响 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
ldr.b  rz, (rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000000 
 00001 
 RY 
 

 
ldr.b  rz, (rx, ry << #1) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000000 
 00010 
 RY 
 

 
ldr.b  rz, (rx, ry << #2) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000000 
 00100 
 RY 
 

 
ldr.b  rz, (rx, ry << #3) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000000 
 01000 
 RY 
 

LDR.BS――寄存器移位寻址有符号扩展字节加载指令 
 
操作： 
 从存储器加载字节到寄存器，有符号扩展 
RZ ← sign_extend(MEM[RX + RY << IMM2]) 
 
yufa:
 ldr.bs  rz, (rx, ry << #0) 
ldr.bs  rz, (rx, ry << #1) 
ldr.bs  rz, (rx, ry << #2) 
ldr.bs  rz, (rx, ry << #3) 
 
说明： 
 从存储器加载的字节经有符号扩展到32位后存放于寄存器RZ中。采用寄存器加寄存器移位的寻址方式。存储器的有效地址由基址寄存器RX加上偏移量寄存器RY左移2位立即数IMM2后的值得到。IMM2的缺省值为0。 
 
影响标志位： 
 无影响 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
ldr.bs  rz, (rx, ry<< #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000100 
 00001 
 RY 
 

 
ldr.bs  rz, (rx, ry<< #1) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000100 
 00010 
 RY 
 

 
ldr.bs  rz, (rx, ry<< #2) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000100 
 00100 
 RY 
 

 
ldr.bs  rz, (rx, ry<< #3) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000100 
 01000 
 RY 
 

LDR.H――寄存器移位寻址无符号扩展半字加载指令 
 
操作： 
 从存储器加载半字到寄存器，无符号扩展 
RZ ← zero_extend(MEM[RX + RY << IMM2]) 
 
yufa:
 ldr.h  rz,(rx, ry << #0) 
ldr.h  rz, (rx, ry << #1) 
ldr.h  rz, (rx, ry << #2) 
ldr.h  rz, (rx, ry << #3) 
 
说明： 
 从存储器加载的半字经零扩展到32位后存放于寄存器RZ中。采用寄存器加寄存器移位的寻址方式。存储器的有效地址由基址寄存器RX加上偏移量寄存器RY左移2位立即数IMM2后的值得到。IMM2的缺省值为0。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
ldr.h  rz,(rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000001 
 00001 
 RY 
 

 
ldr.h  rz,(rx, ry << #1) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000001 
 00010 
 RY 
 

 
ldr.h  rz,(rx, ry << #2) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000001 
 00100 
 RY 
 

 
ldr.h  rz,(rx, ry << #3) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000001 
 01000 
 RY 
 

LDR.HS――寄存器移位寻址有符号扩展半字加载指令 
 
操作： 
 从存储器加载半字到寄存器，有符号扩展 
RZ ← sign_extend(MEM[RX + RY << IMM2]) 
 
yufa:
 ldr.hs  rz, (rx, ry << #0) 
ldr.hs  rz, (rx, ry << #1) 
ldr.hs  rz, (rx, ry << #2) 
ldr.hs  rz, (rx, ry << #3) 
 
说明： 
 从存储器加载的半字经有符号扩展到32位后存放于寄存器RZ中。采用寄存器加寄存器移位的寻址方式。存储器的有效地址由基址寄存器RX加上偏移量寄存器RY左移2位立即数IMM2后的值得到。IMM2的缺省值为0。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
ldr.hs  rz, (rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000101 
 00001 
 RY 
 

 
ldr.hs  rz, (rx, ry << #1) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000101 
 00010 
 RY 
 

 
ldr.hs  rz, (rx, ry << #2) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000101 
 00100 
 RY 
 

 
ldr.hs  rz, (rx, ry << #3) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000101 
 01000 
 RY 
 

LDR.W――寄存器移位寻址字加载指令 
 
操作： 
 从存储器加载字到寄存器 
RZ ← MEM[RX + RY << IMM2] 
 
yufa:
 ldr.w  rz, (rx, ry << #0) 
ldr.w  rz, (rx, ry << #1) 
ldr.w  rz, (rx, ry << #2) 
ldr.w  rz, (rx, ry << #3) 
 
说明： 
 从存储器加载字到寄存器RZ中。采用寄存器加寄存器移位的寻址方式。存储器的有效地址由基址寄存器RX加上偏移量寄存器RY左移2位立即数IMM2后的值得到。IMM2的缺省值为0。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
ldr.w  rz, (rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000010 
 00001 
 RY 
 

 
ldr.w  rz, (rx, ry << #1) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000010 
 00010 
 RY 
 

 
ldr.w  rz, (rx, ry << #2) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000010 
 00100 
 RY 
 

 
ldr.w  rz, (rx, ry << #3 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10100 
 RZ 
 RX 
 000010 
 01000 
 RY 
 

LSL――逻辑左移指令 
 
操作： 
 RZ ← RX << RY[5:0] 
 
yufa:
 lsl  rz, rx, ry 
 
说明： 
 将RX的值进行逻辑左移（原值左移，右侧移入0），结果存入RZ，左移位数由RY低6位（RY[5:0]）的值确定；如果RY[5:0]的值大于31，那么RZ将被清零。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010000 
 00001 
 RY 
 

LSLC――立即数逻辑左移至C位指令 
 
操作： 
 RZ ← RX << OIMM5, C ← RX[32 C OIMM5] 
 
yufa:
 lslc  rz, rx, oimm5 
 
说明： 
 将RX的值进行逻辑左移（原值左移，右侧移入0），把移出最末位存入条件位C，移位结果存入RZ，左移位数由带偏置1的5位立即数（OIMM5）的值决定。如果OIMM5的值等于32，那么条件位C为RX的最低位，RZ被清零。 
注意：二进制操作数IMM5等于OIMM5 - 1。 
 
影响标志位： 
 C ← RX[32 C OIMM5] 
 
限制： 
 立即数的范围为1-32。 
 
异常： 
 无 
 
指令格式： 
  
 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010011 
 00001 
 IMM5 
 

 
IMM5域――指定不带偏置立即数的值。 
注意：移位的值OIMM5比起二进制操作数IMM5需偏置1。 
00000――移1位 
00001――移2位 
…… 
11111――移32位 
LSLI――立即数逻辑左移指令 
 
操作： 
 RZ ← RX << IMM5 
 
yufa:
 lsli  rz, rx, imm5 
 
说明： 
 将RX的值进行逻辑左移（原值左移，右侧移入0），结果存入RZ，左移位数由5位立即数（IMM5）的值决定；如果IMM5的值等于0，那么RZ的值将与RX相同。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010010 
 00001 
 IMM5 
 

LSR――逻辑右移指令 
 
操作： 
 RZ ← RX >> RY[5:0] 
 
yufa:
 lsr  rz, rx, ry 
 
说明： 
 将RX的值进行逻辑右移（原值右移，左侧移入0），结果存入RZ，右移位数由RY低6位（RY[5:0]）的值确定；如果RY[5:0]的值大于31，那么RZ将被清零。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010000 
 00010 
 RY 
 

LSRC――立即数逻辑右移至C位指令 
 
操作： 
 RZ ← RX >> OIMM5, C ← RX[OIMM5 - 1] 
 
yufa:
 lsrc  rz, rx, oimm5 
 
说明： 
 将RX的值进行逻辑右移（原值右移，左侧移入0），把移出最末位存入条件位C，移位结果存入RZ，右移位数由带偏置1的5位立即数（OIMM5）的值决定。如果OIMM5的值等于32，那么条件位C为RX的最高位，RZ被清零。 
注意：二进制操作数IMM5等于OIMM5 - 1。 
 
影响标志位： 
 C ← RX[OIMM5 - 1] 
 
限制： 
 立即数的范围为1-32。 
 
异常： 
 无 
 
指令格式： 
  
 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010011 
 00010 
 IMM5 
 

 
IMM5域――指定不带偏置立即数的值。 
注意：移位的值OIMM5比起二进制操作数IMM5需偏置1。 
00000――移1位 
00001――移2位 
…… 
11111――移32位 
LSRI――立即数逻辑右移指令 
 
操作： 
 RZ ← RX >> IMM5 
 
yufa:
 lsri  rz, rx, imm5 
 
说明： 
 将RX的值进行逻辑右移（原值右移，左侧移入0），结果存入RZ，右移位数由5位立即数（IMM5）的值决定；如果IMM5的值等于0，那么RZ的值将与RX相同。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010010 
 00010 
 IMM5 
 

MFCR――控制寄存器读传送指令 
 
操作： 
 将控制寄存器的内容传送到通用寄存器中 
RZ ← CR<X, sel> 
 
yufa:
 mfcr  rz, cr<x, sel> 
 
属性： 
 特权指令 
 
说明： 
 将控制寄存器CR<x, sel>的内容传送到通用寄存器RZ中。 
 
影响标志位： 
 无影响 
 
异常： 
 特权违反异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 RZ 
 CRX 
 011000 
 00001 
 sel 
 

MFHI――累加器高位读传送指令 
 
操作： 
 将累加器高位寄存器的内容传送到通用寄存器中 
RZ ← HI 
 
yufa:
 mfhi  rz 
 
说明： 
 将64位累加器的高32位寄存器HI的内容传送到通用寄存器RZ中。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 00000 
 100111 
 00001 
 00000 
 

MFLO――累加器低位读传送指令 
 
操作： 
 将累加器低位寄存器的内容传送到通用寄存器中 
RZ ← LO 
 
yufa:
 mflo  rz 
 
说明： 
 将64位累加器的低32位寄存器LO的内容传送到通用寄存器RZ中。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 00000 
 100111 
 00100 
 00000 
 

MOV――数据传送指令* 
 
操作： 
 RZ ← RX 
 
yufa:
 mov  rz, rx 
 
说明： 
 把RX中的值复制到目的寄存器RZ中。 
注意，该指令是lsli  rz, rx, 0x0的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010010 
 00001 
 00000 
 

MOVF――C为0数据传送指令* 
 
操作： 
 if C==0, then 
RZ ← RX; 
else 
  RZ ← RZ; 
 
yufa:
 movf  rz, rx 
 
说明： 
 如果C为0，把RX的值复制到目的寄存器RZ中；否则，RZ的值不变。 
注意，该指令是incf  rz, rx, 0x0的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000011 
 00001 
 00000 
 

MOVI――立即数数据传送指令 
 
操作： 
 RZ ← zero_extend(IMM16); 
 
yufa:
 movi  rz, imm16 
 
说明： 
 将16位立即数零扩展至32位，然后传送至目的RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0x0-0xFFFF。 
 
异常： 
 无 
 
指令格式： 
  
 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00111 
 00000 
 RZ 
 IMM16 
 

 
MOVIH――立即数高位数据传送指令 
 
操作： 
 RZ ← zero_extend(IMM16) << 16 
 
yufa:
 movih  rz, imm16 
 
说明： 
 将16位立即数零扩展至32位，然后逻辑左移16位，传送结果至目的RZ。 
该指令可配合ori  rz, imm16指令产生任意32位立即数。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0x0-0xFFFF。 
 
异常： 
 无 
 
指令格式： 
  
 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00111 
 00001 
 RZ 
 IMM16 
 

MOVT――C为1数据传送指令* 
 
操作： 
 if C==1, then 
RZ ← RX; 
else 
  RZ ← RZ; 
 
yufa:
 movt  rz, rx 
 
说明： 
 如果C为1，把RX的值复制到目的寄存器RZ中；否则，RZ的值不变。 
注意，该指令是inct  rz, rx, 0x0的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000011 
 00010 
 00000 
 

MTCR――控制寄存器写传送指令 
 
操作： 
 将通用寄存器的内容传送到控制寄存器中 
CR<Z, sel> ← RX 
 
yufa:
 mtcr  rx, cr<z, sel> 
 
属性： 
 特权指令 
 
说明： 
 将通用寄存器RZ的内容传送到控制寄存器CR<z, sel>中。 
 
影响标志位： 
 如果目标控制寄存器不是PSR，则该指令不会影响标志位。 
 
异常： 
 特权违反异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 CRZ 
 RX 
 011001 
 00001 
 sel 
 

 
MTHI――累加器高位写传送指令 
 
操作： 
 将通用寄存器的内容传送到累加器高位寄存器中 
HI ← RX 
 
yufa:
 mthi  rx 
 
说明： 
 将通用寄存器RX的内容传送到64位累加器的高32位寄存器HI中。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 100111 
 00010 
 00000 
 

MTLO――累加器低位写传送指令 
 
操作： 
 将通用寄存器的内容传送到累加器低位寄存器中 
LO ← RX 
 
yufa:
 mtlo  rx 
 
说明： 
 将通用寄存器RX的内容传送到64位累加器的低32位寄存器LO中。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 100111 
 01000 
 00000 
 

MULS――有符号数乘法指令 
 
操作： 
 两个有符号数相乘，结果放入累加器中 
{HI, LO} ← RX × RY 
 
yufa:
 muls  rx, ry 
 
说明： 
 将通用寄存器RX和RY的内容相乘后存放到64位累加器中，其中高32位存放于HI中，低32位存放于LO中。通用寄存器RX和RY以及64位累加器中的值均被认为是有符号数。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 100011 
 00001 
 RY 
 

MULSA――有符号数乘累加指令 
 
操作： 
 两个有符号数相乘再加上累加器中的值，结果放回累加器中 
{HI, LO} ← {HI, LO} + RX × RY 
 
yufa:
 mulsa  rx, ry 
 
说明： 
 将通用寄存器RX和RY的内容相乘后再加上64位累加器中的值，结果放回到累加器中。乘累加的结果的高32位存放于HI中，低32位存放于LO中。通用寄存器RX和RY以及64位累加器中的值均被认为是有符号数。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 100011 
 00010 
 RY 
 

MULSH――16位有符号乘法指令 
 
操作： 
 两个16位有符号数相乘，结果放入通用寄存器中 
RZ ← RX[15..0] × RY[15..0] 
 
yufa:
 mulsh  rz, rx, ry 
 
说明： 
 将通用寄存器RX的低16位和RY的低16位相乘后的结果存放到通用寄存器RZ中。寄存器RX、RY和RZ的内容均被认为是有符号数，其中源寄存器RX、RY的符号位是第15位，目标寄存器RZ的符号位是第31位。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 100001 
 00010 
 RY 
 

MULSS――有符号数乘累减指令 
 
操作： 
 累加器中的值减去两个有符号数相乘后的值，结果放回累加器中 
{HI, LO} ← {HI, LO} - RX × RY 
 
yufa:
 mulss  rx, ry 
 
说明： 
 将64位累加器中的值减去通用寄存器RX和RY相乘后的值，结果放回到累加器中。乘累减的结果的高32位存放于HI中，低32位存放于LO中。通用寄存器RX和RY以及64位累加器中的值均被认为是有符号数。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 100011 
 00100 
 RY 
 

MULT――乘法指令 
 
操作： 
 两个数相乘，结果的低32位放入通用寄存器中 
RZ ← RX × RY 
 
yufa:
 mult  rz, rx, ry 
 
说明： 
 将通用寄存器RX和RY的内容相乘后结果的低32位存放到通用寄存器RZ中，结果的高32位舍弃。不管源操作数被认为是有符号数还是无符号数，结果都相同。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 100001 
 00001 
 RY 
 

MULU――无符号数乘法指令 
 
操作： 
 两个无符号数相乘，结果放入累加器中 
{HI, LO} ← RX × RY 
 
yufa:
 mulu  rx, ry 
 
说明： 
 将通用寄存器RX和RY的内容相乘后存放到64位累加器中，其中高32位存放于HI中，低32位存放于LO中。通用寄存器RX和RY以及64位累加器中的值均被认为是无符号数。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 100010 
 00001 
 RY 
 

MULUA――无符号数乘累加指令 
 
操作： 
 两个无符号数相乘再加上累加器中的值，结果放回累加器中 
{HI, LO} ← {HI, LO} + RX × RY 
 
yufa:
 mulua  rx, ry 
 
说明： 
 将通用寄存器RX和RY的内容相乘后再加上64位累加器中的值，结果放回到累加器中。乘累加的结果的高32位存放于HI中，低32位存放于LO中。通用寄存器RX和RY以及64位累加器中的值均被认为是无符号数。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 100010 
 00010 
 RY 
 

MULUS――无符号数乘累减指令 
 
操作： 
 累加器中的值减去两个无符号数相乘后的值，结果放回累加器中 
{HI, LO} ← {HI, LO} - RX × RY 
 
yufa:
 mulus  rx, ry 
 
说明： 
 将64位累加器中的值减去通用寄存器RX和RY相乘后的值，结果放回到累加器中。乘累减的结果的高32位存放于HI中，低32位存放于LO中。通用寄存器RX和RY以及64位累加器中的值均被认为是无符号数。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 100010 
 00100 
 RY 
 

MVC――C位传送指令 
 
操作： 
 RZ ← C 
 
yufa:
 mvc  rz 
 
说明： 
 把条件位C传送到RZ的最低位，RZ的其它位清零。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 00000 
 011000 
 00001 
 00000 
 

MVCV――C位取反传送指令 
 
操作： 
 RZ ← (!C) 
 
yufa:
 mvcv  rz 
 
说明： 
 把条件位C取反后传送到RZ的最低位，RZ的其它位清零。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 00000 
 011111 
 00001 
 00000 
 

NOR――按位或非指令 
 
操作： 
 RZ ← !(RX | RY) 
 
yufa:
 nor  rz, rx, ry 
 
说明： 
 将RX与RY的值按位或，然后按位取非，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 001001 
 00100 
 RY 
 

NOT――按位非指令* 
 
操作： 
 RZ ← !(RX) 
 
yufa:
 not  rz, rx 
 
说明： 
 将RX的值按位取反，把结果存在RZ。 
注意，该指令是nor  rz, rx, rx的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 001001 
 00100 
 RX 
 

OR――按位或指令 
 
操作： 
 RZ ← RX | RY 
 
yufa:
 or  rz, rx, ry 
 
说明： 
 将RX与RY的值按位或，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 001001 
 00001 
 RY 
 

ORI――立即数按位或指令 
 
操作： 
 RZ ← RX | zero_extend(IMM16) 
 
yufa:
 ori  rz, rx, imm16 
 
说明： 
 将16位立即数零扩展至32位，然后与RX的值进行按位或操作，把结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0x0-0xFFFF。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 01100 
 RZ 
 RX 
 Offset 
 

PLDR――读数据预取指令 
 
操作： 
 读数据预取 
 
yufa:
 pldr  (rx, offset) 
 
说明： 
 读数据预取指令的目的是加速数据的加载行为。在数据加载前，使用PLDR指令将该数据行读入到Cache中；在加载数据的Load指令执行时，命中在D-Cache中，从而加快数据加载的效率。 
读数据预取的有效地址由基址寄存器RX加上左移两位的16相对偏移量无符号扩展到32位后的值得到。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00111 
 11000 
 RX 
 Offset 
 

 
PLDW――写数据预取指令 
 
操作： 
 写数据预取 
 
yufa:
 pldw  (rx, offset) 
 
说明： 
 写数据预取指令的目的是加速写分配Cache策略下数据的存储行为。在写分配Cache的策略下，存储指令Cache未命中会导致一次Cache回填操作。PLDW指令在存储指令之前将即将存储的数据所在的行读入到Cache；在存储数据的Store指令执行时，命中在D-Cache中，从而加快数据存储的效率。 
写数据预取的有效地址由基址寄存器RX加上左移两位的16相对偏移量无符号扩展到32位后的值得到。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 00111 
 11001 
 RX 
 Offset 
 

 
PSRCLR――PSR位清零指令 
 
操作： 
 清除状态寄存器的某一位或几位 
PSR({EE，IE，FE，AF}) ← 0 
 
yufa:
 psrclr  #imm5 
 
属性： 
 特权指令 
 
说明： 
 选中的PSR位被清零（1表示选中）。五位立即数IMM5用于编码要清除的控制位，对应关系如下： 
立即数IMM5各位 
 对应的PSR控制位 
 
Imm5[0] 
 AF 
 
Imm5[1] 
 FE 
 
Imm5[2] 
 IE 
 
Imm5[3] 
 EE 
 
Imm5[4] 
 保留 
 

 
 
影响标志位： 
 无影响 
 
异常： 
 特权违反异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 011100 
 00001 
 IMM5 
 

PSRSET――PSR位置位指令 
 
操作： 
 设置状态寄存器的某几位 
PSR({EE，IE，FE，AF}) ← 1 
 
yufa:
 psrset  #imm5 
 
属性： 
 特权指令 
 
说明： 
 选中的PSR位被置位（1表示选中）。五位立即数IMM5用于编码要清除的控制位，对应关系如下： 
立即数IMM5各位 
 对应的PSR控制位 
 
Imm5[0] 
 AF 
 
Imm5[1] 
 FE 
 
Imm5[2] 
 IE 
 
Imm5[3] 
 EE 
 
Imm5[4] 
 保留 
 

 
 
影响标志位： 
 无影响 
 
异常： 
 特权违反异常 
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 011101 
 00001 
 IMM5 
 

 
REVB――字节倒序指令 
 
操作： 
 RZ[31:24]  ←  RX[7:0]; 
RZ[23:16]  ←  RX[15:8]; 
RZ[15:8]   ←  RX[23:16]; 
RZ[7:0]    ←  RX[31:24]; 
 
yufa:
 revb  rz, rx 
 
说明： 
 把RX的值按字节取倒序，各字节内部的位顺序保持不变，结果存入RZ。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 011000 
 00100 
 00000 
 

REVH――半字字节倒序指令 
 
操作： 
 RZ[31:24]  ←  RX[23:16]; 
RZ[23:16]  ←  RX[31:24]; 
RZ[15:8]   ←  RX[7:0]; 
RZ[7:0]    ←  RX[15:8]; 
 
yufa:
 revb  rz, rx 
 
说明： 
 把RX的值在半字内按字节取倒序，即分别交换高半字内的两个字节和低半字内的两个字节，两个半字间的顺序和各字节内的位顺序保持不变，结果存入RZ。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 00000 
 011000 
 01000 
 IMM5 
 

RFI――快速中断返回指令 
 
操作： 
 快速中断返回 
PC ← FPC，PSR ← FPSR 
 
yufa:
 rfi 
 
属性： 
 特权指令 
 
说明： 
 PC值恢复为保存在控制寄存器FPC中的值，PSR值恢复为保存在FPSR的值，指令执行从新的PC地址处开始。 
 
影响标志位： 
 无影响 
 
异常： 
 特权违反异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 010001 
 00001 
 00000 
 

 
ROTL――循环左移指令 
 
操作： 
 RZ ← RX <<<< RY[5:0] 
 
yufa:
 rotl  rz, rx, ry 
 
说明： 
 将RX的值进行循环左移（原值左移，右侧移入左侧移出的位），结果存入RZ，左移位数由RY低6位（RY[5:0]）的值决定；如果RY[5:0]的值等于32，那么RZ的值将与RX相同。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010000 
 01000 
 RY 
 

ROTLI――立即数循环左移指令 
 
操作： 
 RZ ← RX <<<< IMM5 
 
yufa:
 rotli  rz, rx, imm5 
 
说明： 
 将RX的值进行循环左移（原值左移，右侧移入左侧移出的位），结果存入RZ，左移位数由5位立即数（IMM5）的值决定；如果IMM5的值等于0，那么RZ的值将与RX相同。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010010 
 01000 
 IMM5 
 

 
RSUB――反向减法指令* 
 
操作： 
 RZ ← RY - RX 
 
yufa:
 rsub  rz, rx, ry 
 
说明： 
 将RY的值减去RX值，并把结果存在RZ中。 
注意，该指令是subu  rz, ry, rx的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RY 
 000000 
 00100 
 RX 
 

RTE――异常和普通中断返回指令 
 
操作： 
 异常和普通中断返回 
PC ← EPC，PSR ← EPSR 
 
yufa:
 rte 
 
属性： 
 特权指令 
 
说明： 
 PC值恢复为保存在控制寄存器EPC中的值，PSR值恢复为保存在EPSR的值，指令执行从新的PC地址处开始。 
 
影响标志位： 
 无影响 
 
异常： 
 特权违反异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 010000 
 00001 
 00000 
 

 
SE――事件发送指令 
 
操作： 
 向处理器外部发送事件 
 
yufa:
 se 
 
说明： 
 处理器内核与外部设备之间的通信机制，可用作多核通信。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 010110 
 00001 
 00000 
 

 
SEXT――位提取并有符号扩展指令 
 
操作： 
 RZ ← sign_extend(RX[MSB:LSB]) 
 
yufa:
 sext  rz, rx, msb, lsb 
 
说明： 
 提取由2个5位立即数（MSB,LSB）所指定的RX的一段连续位（RX[MSB:LSB]），符号扩展至32位，并把结果存入RZ。如果MSB等于31，且LSB等于0，则RZ的值与RX相同。如果MSB等于LSB，则RZ的值为RX[MSB]（即RX[LSB]）一位符号扩展的结果。如果MSB小于LSB，该指令的行为不可预测。 
 
影响标志位： 
 无影响 
 
限制： 
 MSB的范围为0-31，LSB的范围为0-31，且MSB应当大于等于LSB。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010110 
 MSB 
 LSB 
 

 
MSB域――指定被提取起始的位。 
00000――0位 
00001――1位 
…… 
11111――31位 
 
LSB域――指定被提取结束的位。 
00000――0位 
00001――1位 
…… 
11111――31位 
 
SEXTB――字节提取并有符号扩展指令* 
 
操作： 
 RZ ← sign_extend(RX[7:0]); 
 
yufa:
 sextb  rz, rx 
 
说明： 
 将RX的低字节（RX[7:0]）符号扩展至32位，结果存在RZ中。 
注意，该指令是sext  rz, rx, 0x7, 0x0的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010110 
 00111 
 00000 
 

 
SEXTH――半字提取并有符号扩展指令* 
 
操作： 
 RZ ← sign_extend(RX[15:0]); 
 
yufa:
 sextb  rz, rx 
 
说明： 
 将RX的低半字（RX[15:0]）符号扩展至32位，结果存在RZ中。 
注意，该指令是sext  rz, rx, 0x15, 0x0的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010110 
 01111 
 00000 
 

ST.B――字节存储指令 
 
操作： 
 将寄存器中的最低字节存储到存储器中 
MEM[RX + unsign_extend(offset)] ← RZ[7:0] 
 
yufa:
 st.b  rz, (rx, offset) 
 
说明： 
 将寄存器RZ中的最低字节存储到存储器中。采用寄存器加无符号立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上12位相对偏移量无符号扩展到32位后的值得到。ST.B指令可以寻址+4KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10111 
 RZ 
 RX 
 0000 
 Offset 
 

 
ST.H――半字存储指令 
 
操作： 
 将寄存器中的低半字存储到存储器中 
MEM[RX + unsign_extend(offset << 1)] ← RZ[15:0] 
 
yufa:
 st.h  rz, (rx, offset) 
 
说明： 
 将寄存器RZ中的低半字存储到存储器中。采用寄存器加无符号立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移1位的12位相对偏移量无符号扩展到32位后的值得到。ST.H指令可以寻址+8KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0
 10111 
 RZ 
 RX 
 0001 
 Offset 
 

 
ST.W――字存储指令 
 
操作： 
 将寄存器中的字存储到存储器中 
MEM[RX + unsign_extend(offset << 2)] ← RZ[31:0] 
 
yufa:
 st.w  rz, (rx, offset) 
 
说明： 
 将寄存器RZ中的字存储到存储器中。采用寄存器加无符号立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移两位的12位相对偏移量无符号扩展到32位后的值得到。ST.W指令可以寻址+16KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10111 
 RZ 
 RX 
 0010 
 Offset 
 

 
STCPR――协处理器字存储指令 
 
操作： 
 将协处理器通用寄存器中的字存储到存储器中  
MEM[RX + sign_extend(offset << 2)] ← CPRZ 
 
yufa:
 stcpr  <cpid, cprz>, (rx, offset) 
 
说明： 
 将协处理器通用寄存器CPRZ中的字存储到存储器中。采用寄存器加立即数偏移量的寻址方式。指令低12位编码空间中8~11位约定为协处理器号，用于指定预操作的协处理器，其余8位为相对偏移量。存储器的有效地址由主流水线基址寄存器RX加上左移两位的8位相对偏移量无符号扩展到32位后的值得到。STCPR指令可以寻址+1KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10110 
 CPRZ 
 RX 
 1000 
 User-define 
 

 
STEX.W――独占式字存储指令 
 
操作： 
 if 独占式字存储成功, then 
  MEM[RX + sign_extend(offset << 2)] ← RZ; 
  RZ ← 1; 
else 
  RZ ← 0; 
 
yufa:
 stex.w  rz, (rx, offset) 
 
说明： 
 将通用寄存器RZ中的字存储到存储器中，若独占存储成功，则源寄存器RZ返回1；否则源寄存器返回0表示独占存储失败。STEX.W采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移两位的12相对偏移量无符号扩展到32位后的值得到。STEX.W指令可以寻址+16KB空间。 
该指令与LDEX.W配对，用于多核通信时的原子“读存储器―修改―写存储器”操作。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15     12 11 
 0 
 
0 
 10111 
 RZ 
 RX 
 0111 
 Offset 
 

 
STM――连续多字存储指令 
 
操作： 
 将一片连续的寄存器堆中内容依次存储到一片连续的存储器地址上。 
dst ← Z C IMM5; addr ← RX; 
for (n = 0; n <= IMM5; n++){ 
  MEM[addr] ← Rdst; 
  dst ← dst + 1; 
  addr ← addr + 4; 
} 
 
yufa:
 stm  ry-rz, (rx) 
 
说明： 
 将从RY开始的一片连续的寄存器堆中的内容依次存储到一片连续的存储器地址上，即将寄存器RY的内容存到存储器指定地址开始的第一个字的地址上，寄存器RY+1的内容存到存储器指定地址开始的第二个字的地址上，依次类推，将寄存器RZ的内容存到存储器指定地址开始的最后一个字的地址上。存储器的有效地址由基址寄存器RX的内容决定。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000111 
 00001 
 IMM5 
 

 
IMM5域――指定目标寄存器的个数，IMM5 = Z - Y。 
00000――1个目的寄存器 
00001――2个目的寄存器 
…… 
11111――32个目的寄存器 
 
STOP――进入低功耗暂停模式指令 
 
操作： 
 进入低功耗暂停模式 
 
yufa:
 stop 
 
属性： 
 特权指令 
 
说明： 
 此指令使处理器进入低功耗模式，并等待一个中断来退出这个模式。此时，CPU时钟停止，大部分外围设备也被停止。 
 
影响标志位： 
 无影响 
 
异常： 
 特权违反异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 010010 
 00001 
 00000 
 

STQ――连续四字存储指令* 
 
操作： 
 将寄存器R4―R7中的字依次存储到一片连续的存储器地址上。 
dst ← 4; addr ← RX; 
for (n = 0; n <= 3; n++){ 
  MEM[addr] ← Rdst; 
  dst ← dst + 1; 
  addr ← addr + 4; 
} 
 
yufa:
 stq  r4-r7, (rx) 
 
说明： 
 将寄存器堆[R4,R7]（包括边界）中的字依次存储到一片连续的存储器地址上，即将寄存器R4的内容存到存储器指定地址开始的第一个字的地址上，寄存器R5的内容存到存储器指定地址开始的第二个字的地址上，寄存器R6的内容存到存储器指定地址开始的第三个字的地址上，寄存器R7的内容存到存储器指定地址开始的第四个字的地址上。存储器的有效地址由基址寄存器RX的内容决定。 
注意，该指令是stm r4-r7, (rx)的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 00100 
 RX 
 000111 
 00001 
 00011 
 

 
STR.B――寄存器移位寻址字节存储指令 
 
操作： 
 将寄存器中的最低字节存储到存储器中  
MEM[RX + RY << IMM2] ← RZ[7:0] 
 
yufa:
 str.b  rz, (rx, ry << #0) 
str.b  rz, (rx, ry << #1) 
str.b  rz, (rx, ry << #2) 
str.b  rz, (rx, ry << #3) 
 
说明： 
 将寄存器RZ中的最低字节存储到存储器中。采用寄存器加寄存器移位寻址方式。存储器的有效地址由基址寄存器RX加上偏移量寄存器RY左移2位立即数IMM2后的值得到。IMM2的缺省值为0。 
 
影响标志位： 
 无影响 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
str.b  rz, (rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000000 
 00001 
 RY 
 

 
str.b  rz, (rx, ry << #1) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000000 
 00010 
 RY 
 

 
str.b  rz, (rx, ry << #2) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000000 
 00100 
 RY 
 

 
str.b  rz, (rx, ry << #3) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000000 
 01000 
 RY 
 

STR.H――寄存器移位寻址半字存储指令 
 
操作： 
 将寄存器中的低半字存储到存储器中 
MEM[RX + RY << IMM2] ← RZ[15:0] 
 
yufa:
 str.h  rz, (rx, ry << #0) 
str.h  rz, (rx, ry << #1) 
str.h  rz, (rx, ry << #2) 
str.h  rz, (rx, ry << #3) 
 
说明： 
 将寄存器RZ中的低半字存储到存储器中。采用寄存器加寄存器移位寻址方式。存储器的有效地址由基址寄存器RX加上偏移量寄存器RY左移2位立即数IMM2后的值得到。IMM2的缺省值为0。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
str.h  rz, (rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000001 
 00001 
 RY 
 

 
str.h  rz, (rx, ry << #1) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000001 
 00010 
 RY 
 

 
str.h  rz, (rx, ry << #2) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000001 
 00100 
 RY 
 

 
str.h  rz, (rx, ry << #3) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000001 
 01000 
 RY 
 

STR.W――寄存器移位寻址字存储指令 
 
操作： 
 将寄存器中的字存储到存储器中 
MEM[RX + RY << IMM2] ← RZ[31:0] 
 
yufa:
 str.w  rz, (rx, ry << #0) 
str.w  rz, (rx, ry << #1) 
str.w  rz, (rx, ry << #2) 
str.w  rz, (rx, ry << #3) 
 
说明： 
 将寄存器RZ中的字存储到存储器中。采用寄存器加寄存器移位寻址方式。存储器的有效地址由基址寄存器RX加上偏移量寄存器RY左移2位立即数IMM2后的值得到。IMM2的缺省值为0。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB写无效异常 
 
指令格式： 
  
 

 
str.w  rz, (rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000010 
 00001 
 RY 
 

 
str.w  rz, (rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000010 
 00010 
 RY 
 

 
str.w  rz, (rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000010 
 00100 
 RY 
 

 
str.w  rz, (rx, ry << #0) 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10101 
 RZ 
 RX 
 000010 
 01000 
 RY 
 

SUBC――无符号带借位减法指令 
 
操作： 
 RZ ← RX - RY -（!C），C ← 借位 
 
yufa:
 subc  rz, rx, ry 
 
说明： 
 将RX的值减去寄存器RY的值和C位的非值，并把结果存在RZ，借位存在C位。对于该减法指令来说，如果发生借位，将清C位，反之置C位。 
 
影响标志位： 
 C ← 借位 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000000 
 01000 
 RY 
 

SUBI――无符号立即数减法指令 
 
操作： 
 RZ ← RX - zero_extend(OIMM16) 
 
yufa:
 subi  rz, rx, oimm16 
 
说明： 
 将带偏置1的16位立即数（OIMM16）零扩展至32位，然后用RX的值减去该32位数，把结果存入RZ。 
注意：二进制操作数IMM16等于OIMM16 - 1。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0x1-0x1000。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 01001 
 RZ 
 RX 
 IMM16 
 

 
IMM16域――指定不带偏置立即数的值。 
注意：寄存器减去的值OIMM16比起二进制操作数IMM16需偏置1。 
0000000000000000――减0x1 
0000000000000001――减0x2 
…… 
1111111111111111――减0x10000 
 
SUBU――无符号减法指令 
 
操作： 
 RZ ← RX - RY 
 
yufa:
 subu  rz, rx, ry 
 
说明： 
 将RX的值减去RY值，并把结果存在RZ中。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 000000 
 00100 
 RY 
 

 
SYNC――CPU同步指令 
 
操作： 
 使CPU同步 
 
yufa:
 sync 
 
说明： 
 当处理器碰到sync指令时，指令就会被悬挂起来直到所有外面的操作全都完成，即没有未完成的指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 000001 
 00001 
 00000 
 

TRAP――操作系统陷阱指令 
 
操作： 
 引起陷阱异常发生 
 
yufa:
 trap  #0 
trap  #1 
trap  #2 
trap  #3 
 
说明： 
 当处理器碰到trap指令时，发生陷阱异常操作。 
 
影响标志位： 
 无影响 
 
异常： 
 陷阱异常 
 
指令格式： 
  
 

 
trap  #0 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 001000 
 00001 
 00000 
 

 
trap  #1 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 001001 
 00001 
 00000 
 

 
trap  #2 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 001010 
 00001 
 00000 
 

 
trap  #3 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 001011 
 00001 
 00000 
 

TST――零测试指令 
 
操作： 
 If (RX & RY) != 0, then 
C ← 1; 
else 
  C ← 0; 
 
yufa:
 tst  rx, ry 
 
说明： 
 测试RX和RY的值按位与的结果。 
如果结果不等于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据按位与结果设置条件位C 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 00000 
 RX 
 001000 
 00100 
 RY 
 

 
TSTNBZ――无字节等于零寄存器测试指令 
 
操作： 
 If  ( (RX[31:24] != 0) 
&(RX[23:16] != 0) 
&(RX[15: 8 ] != 0) 
&(RX[ 7 : 0 ] != 0) ), then 
C ← 1; 
else 
  C ← 0; 
 
yufa:
 tstnbz  rx 
 
说明： 
 测试RX中是否没有字节等于零。如果RX没有字节等于零，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据按位与结果设置条件位C 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 
0 
 10001 
 00000 
 RX 
 001000 
 

WAIT――进入低功耗等待模式指令 
 
操作： 
 进入低功耗等待模式 
 
yufa:
 wait 
 
属性： 
 特权指令 
 
说明： 
 此指令停止当前指令执行，并等待一个中断，此时CPU时钟停止。所有的外围设备都仍在继续运行，并有可能会产生中断而引起CPU从等待模式退出。 
 
影响标志位： 
 无影响 
 
异常： 
 特权违反指令 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 010011 
 00001 
 00000 
 

WE――事件等待指令 
 
操作： 
 等待事件 
 
yufa:
 we 
 
说明： 
 执行WE指令CPU进入等待事件状态并进入低功耗状态，等待其它处理器核发送事件以唤醒。 
 
影响标志位： 
 无影响 
 
异常： 
 特权违反指令 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10000 
 00000 
 00000 
 010101 
 00001 
 00000 
 

XOR――按位异或指令 
 
操作： 
 RZ ← RX ^ RY 
 
yufa:
 xor  rz, rx, ry 
 
说明： 
 将RX与RY的值按位异或，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 001001 
 00010 
 RY 
 

XORI――立即数按位异或指令 
 
操作： 
 RZ ← RX ^ zero_extend(IMM16) 
 
yufa:
 xori  rz, rx, imm16 
 
说明： 
 将16位立即数零扩展至32位，然后与RX的值进行按位异或操作，把结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 立即数的范围为0x0-0xFFFF。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
 0 
 
0 
 01101 
 RZ 
 RX 
 IMM16 
 

XSR――扩展右移指令 
 
操作： 
 {RZ,C} ←{RX,C} >>>> OIMM5 
 
yufa:
 xsr  rz, rx, oimm5 
 
说明： 
 将RX带条件位C的值（{RX,C}）进行循环右移（原值右移，左侧移入右侧移出的位），把移位结果的最低位（[0]）存入条件位C，高位（[32:1]）存入RZ，右移位数由带偏置1的5位立即数（OIMM5）的值决定。如果OIMM5的值等于32，那么条件位C为RX的最高位。 
注意：二进制操作数IMM5等于OIMM5 - 1。 
 
影响标志位： 
 C ← RX[OIMM5 - 1] 
 
限制： 
 立即数的范围为1-32。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010011 
 01000 
 IMM5 
 

 
IMM5域――指定不带偏置立即数的值。 
注意：移位的值OIMM5比起二进制操作数IMM5需偏置1。 
00000――移1位 
00001――移2位 
…… 
11111――移32位 
XTRB0――提取字节0并无符号扩展指令 
 
操作： 
 RZ ← zero_extend(RX[31:24]);  
if (RX[31:24] == 0), then 
  C ← 0; 
else 
  C ← 1; 
 
yufa:
 xtrb0  rz, rx 
 
说明： 
 提取RX的字节0（RX[31:24]）到RZ的低位（RZ[7:0]），并进行零扩展。如果结果等于0，则清除C位，反之设置C位。 
 
影响标志位： 
 如果结果等于0，则清除C位，反之设置C位。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 011100 
 00001 
 00000 
 

XTRB1――提取字节1并无符号扩展指令 
 
操作： 
 RZ ← zero_extend(RX[23:16]); 
if (RX[23:16] == 0), then 
  C ← 0; 
else 
  C ← 1; 
 
yufa:
 xtrb1  rz, rx 
 
说明： 
 提取RX的字节1（RX[23:16]）到RZ的低位（RZ[7:0]），并进行零扩展。如果结果等于0，则清除C位，反之设置C位。 
 
影响标志位： 
 如果结果等于0，则清除C位，反之设置C位。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 011100 
 00010 
 00000 
 

XTRB2――提取字节2并无符号扩展指令 
 
操作： 
 RZ ← zero_extend(RX[15:8]); 
if (RX[15:8] == 0), then 
  C ← 0; 
else 
  C ← 1; 
 
yufa:
 xtrb2  rz, rx 
 
说明： 
 提取RX的字节2（RX[15:8]）到RZ的低位（RZ[7:0]），并进行零扩展。如果结果等于0，则清除C位，反之设置C位。 
 
影响标志位： 
 如果结果等于0，则清除C位，反之设置C位。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 011100 
 00100 
 00000 
 

XTRB3――提取字节3并无符号扩展指令 
 
操作： 
 RZ ← zero_extend(RX[7:0]); 
if (RX[7:0] == 0), then 
  C ← 0; 
else 
  C ← 1; 
 
yufa:
 xtrb3  rz, rx 
 
说明： 
 提取RX的字节3（RX[7:0]）到RZ的低位（RZ[7:0]），并进行零扩展。如果结果等于0，则清除C位，反之设置C位。 
 
影响标志位： 
 如果结果等于0，则清除C位，反之设置C位。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 011100 
 01000 
 00000 
 

ZEXT――位提取并无符号扩展指令 
 
操作： 
 RZ ← zero_extend(RX[MSB:LSB]) 
 
yufa:
 zext  rz, rx, msb, lsb 
 
说明： 
 提取由2个5位立即数（MSB,LSB）所指定的RX的一段连续位（RX[MSB:LSB]），零扩展至32位，并把结果存入RZ。如果MSB等于31，且LSB等于0，则RZ的值与RX相同。如果MSB等于LSB，则RZ的值为RX[MSB]（即RX[LSB]）一位零扩展的结果。如果MSB小于LSB，该指令的行为不可预测。 
 
影响标志位： 
 无影响 
 
限制： 
 MSB的范围为0-31，LSB的范围为0-31，且MSB应当大于等于LSB。 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010101 
 MSB 
 LSB 
 

 
MSB域――指定被提取起始的位。 
00000――0位 
00001――1位 
…… 
11111――31位 
 
LSB域――指定被提取结束的位。 
00000――0位 
00001――1位 
…… 
11111――31位 
 
ZEXTB――字节提取并无符号扩展指令* 
 
操作： 
 RZ ← zero_extend(RX[7:0]); 
 
yufa:
 zextb  rz, rx 
 
说明： 
 将RX的低字节（RX[7:0]）零扩展至32位，结果存在RZ中。 
注意，该指令是zext  rz, rx, 0x7, 0x0的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010101 
 00111 
 00000 
 

ZEXTH――半字提取并无符号扩展指令* 
 
操作： 
 RZ ← zero_extend(RX[15:0]); 
 
yufa:
 zextb  rz, rx 
 
说明： 
 将RX的低半字（RX[15:0]）零扩展至32位，结果存在RZ中。 
注意，该指令是zext  rz, rx, 0x15, 0x0的伪指令。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
31 
 30 
 26 
 25 
 21 
 20 
 16 
 15 
  
 10 
 9 
 5 
 4 
 0 
 
0 
 10001 
 RZ 
 RX 
 010101 
 01111 
 00000 
 

4.2. 16位指令 
以下是CSKY V2中16位指令的具体描述。 
ADDC――无符号带进位加法指令 
 
操作： 
 RZ ← RZ+RX+C，C←进位 
 
yufa:
 addc  rz, rx 
 
说明： 
 将RZ、RX与C位的值相加，并把结果存在RZ，进位存在C位。 
 
影响标志位： 
 C ← 进位 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11000 
 RZ 
 RX 
 01 
 

 
ADDI――无符号立即数加法指令 
 
操作： 
 RZ ← RZ + zero_extend(OIMM5) 
 
yufa:
 addi  rz, oimm5 
 
说明： 
 将带偏置1的5位立即数（OIMM5）零扩展至32位，然后与RZ的值相加，把结果存入RZ。 
注意：二进制操作数IMM5等于OIMM5 - 1。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为1-32。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01000 
 RZ 
 IMM5 
 0 
 

 
IMM5域――指定不带偏置立即数的值。 
注意：加到寄存器里的值OIMM5比起二进制操作数IMM5需偏置1。 
00000――加1 
00001――加2 
…… 
11111――加32 
 
ADDU――无符号加法指令 
 
操作： 
 RZ ← RZ+RX 
 
yufa:
 addu  rz, rx 
add  rz, rx 
 
说明： 
 将RZ与RX的值相加，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11000 
 RZ 
 RX 
 00 
 

 
 
AND――按位与指令 
 
操作： 
 RZ ← RZ & RX 
 
yufa:
 and  rz, rx 
 
说明： 
 将RZ与RX的值按位与，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11010 
 RZ 
 RX 
 00 
 

 
ANDN――按位非与指令 
 
操作： 
 RZ ← RZ & (!RX) 
 
yufa:
 andn  rz, rx 
 
说明： 
 将RZ的值与RX的非值按位与，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11010 
 RZ 
 RX 
 01 
 

 
ASR――算术右移指令 
 
操作： 
 RZ ← RZ >>> RX[5:0] 
 
yufa:
 asr  rz, rx 
 
说明： 
 将RZ的值进行算术右移（原值右移，左侧移入原符号位的拷贝），结果存入RZ，右移位数由RX低6位（RX[5:0]）的值决定；如果RX[5:0]的值大于30，那么RZ的值（0或-1）由RZ原值的符号位决定。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11100 
 RZ 
 RX 
 10 
 

 
ASRI――立即数算术右移指令 
 
操作： 
 RZ ← RZ >>> IMM5 
 
yufa:
 asri  rz, imm5 
 
说明： 
 将RZ的值进行算术右移（原值右移，左侧移入原符号位的拷贝），结果存入RZ，右移位数由5位立即数（IMM5）的值决定；如果IMM5的值等于0，那么RZ的值将不变。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01100 
 RZ 
 IMM5 
 0 
 

 
BCLRI――立即数位清零指令 
 
操作： 
 RZ ← RZ[IMM5]清零 
 
yufa:
 bclri  rz, imm5 
 
说明： 
 将RZ的值中，由IMM5域值所指示的位清零，其余位保持不变，把清零后的结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01101 
 RZ 
 IMM5 
 0 
 

 
BF――C为0分支指令 
 
操作： 
 C等于零则程序转移 
if(C==0) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 2 
 
yufa:
 bf  label 
 
说明： 
 如果条件标志位C等于0，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 2。 
Label由当前程序PC加上左移1位的10位相对偏移量有符号扩展到32位后的值得到。BT指令的转移范围是±1KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 00011 
 Offset 
 

 
BR――无条件跳转指令 
 
操作： 
 PC ← PC + sign_extend(offset << 1) 
 
yufa:
 br  label 
 
说明： 
 程序无条件跳转到label处执行。 
Label由当前程序PC加上左移1位的10位相对偏移量有符号扩展到32位后的值得到。BR指令的跳转范围是±1KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 00000 
 Offset 
 

 
BSETI――立即数位置位指令 
 
操作： 
 RZ ← RZ[IMM5]置位 
 
yufa:
 bseti  rz, imm5 
 
说明： 
 将RZ的值中，由IMM5域值所指示的位置1，其余位保持不变，把置位后的结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01101 
 RZ 
 IMM5 
 1 
 

 
BSR――跳转到子程序指令 
 
操作： 
 链接并跳转到子程序： 
R31 ← PC + 2 
PC ← PC + sign_extend(offset << 1) 
 
yufa:
 bsr  label 
 
说明： 
 子程序跳转，将子程序的返回地址（下一条指令的PC，即当前PC + 2）保存在链接寄存器R31中，程序转移到label处执行。 
Label由当前程序PC加上左移1位的10位相对偏移量有符号扩展到32位后的值得到。BSR指令的跳转范围是±1KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 00001 
 Offset 
 

 
BT――C为1分支指令 
 
操作： 
 C等于一则程序转移 
if(C == 1) 
  PC ← PC + sign_extend(offset << 1) 
else 
  PC ← PC + 2 
 
yufa:
 bt  label 
 
说明： 
 如果条件标志位C等于1，则程序转移到label处执行；否则程序执行下一条指令，即PC ← PC + 2。 
Label由当前程序PC加上左移1位的10位相对偏移量有符号扩展到32位后的值得到。BT指令的转移范围是±1KB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 00010 
 Offset 
 

 
CMPHS――无符号大于等于比较指令 
 
操作： 
 RY与RX作无符号比较。 
If RY >= RX, then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmphs  ry, rx 
 
说明： 
 将RY的值减去RX的值，结果与0作比较，并对C位进行更新。cmphs进行无符号比较，即操作数被认为是无符号数。如果RY大于等于RX，即减法结果大于等于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11001 
 RY 
 RX 
 00 
 

 
CMPHSI――立即数无符号大于等于比较指令 
 
操作： 
 RY与立即数作无符号比较。 
If RY >= zero_extend(OIMM5), then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmphsi  ry, oimm5 
 
说明： 
 将带偏置1的5位立即数（OIMM5）零扩展至32位，然后用RX的值减去该32位值，结果与0作比较，并对C位进行更新。cmphsi进行无符号比较，即操作数被认为是无符号数。如果RX大于等于零扩展后的OIMM5，即减法结果大于等于0，则设置条件位C；否则，清除条件位C。 
注意：二进制操作数IMM5等于OIMM5 - 1。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为1-32。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01001 
 RY 
 IMM5 
 0 
 

 
IMM5域――指定不带偏置立即数的值。 
注意：参与比较的立即数OIMM5比起二进制操作数IMM5需偏置1。 
00000――与1比较 
00001――与2比较 
…… 
11111――与32比较 
CMPLT――有符号小于比较指令 
 
操作： 
 RY与RX作有符号比较。 
If RY < RX, then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmplt  ry, rx 
 
说明： 
 将RY的值减去RX的值，结果与0作比较，并对C位进行更新。cmplt进行有符号比较，即操作数被认为是补码形式的有符号数。如果RY小于RX，即减法结果小于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11001 
 RY 
 RX 
 01 
 

 
CMPLTI――立即数有符号小于比较指令 
 
操作： 
 RY与立即数作有符号比较。 
If RY < zero_extend(OIMM5), then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmplti  ry, oimm5 
 
说明： 
 将带偏置1的5位立即数（OIMM5）零扩展至32位，然后用RX的值减去该32位值，结果与0作比较，并对C位进行更新。cmplti进行有符号比较，即RX的值被认为是补码形式的有符号数。如果RX小于零扩展后的OIMM5，即减法结果小于0，则设置条件位C；否则，清除条件位C。 
注意：二进制操作数IMM5等于OIMM5 - 1。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为1-32。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01001 
 RY 
 IMM5 
 1 
 

 
IMM5域――指定不带偏置立即数的值。 
注意：参与比较的立即数OIMM5比起二进制操作数IMM5需偏置1。 
00000――与1比较 
00001――与2比较 
…… 
11111――与32比较 
 
CMPNE――不等比较指令 
 
操作： 
 RY与RX作比较。 
If RY != RX, then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmpne  ry, rx 
 
说明： 
 将RY的值减去RX的值，结果与0作比较，并对C位进行更新。如果RY不等于RX，即减法结果不等于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11001 
 RY 
 RX 
 10 
 

 
CMPNEI――立即数不等比较指令 
 
操作： 
 RY与立即数作比较。 
If RY != zero_extend(IMM5), then 
C ← 1; 
else 
C ← 0; 
 
yufa:
 cmpnei  ry, imm5 
 
说明： 
 将RY的值减去零扩展至32位的5位立即数的值，结果与0作比较，并对C位进行更新。如果RY不等于零扩展后的IMM5，即减法结果不等于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据比较结果设置条件位C 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01010 
 RY 
 IMM5 
 0 
 

 
JMPLR――子程序返回指令 
 
操作： 
 程序跳转到链接寄存器指定的位置 
PC ← R31 & 0xfffffffe 
 
yufa:
 jmplr 
 
说明： 
 程序跳转到链接寄存器R31指定的位置，链接寄存器的最低位被忽略。JMPLR指令的跳转范围是全部4GB地址空间。 
该指令用于实现子程序返回功能。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 11111 
 0000 
 0000 
 00 
 

 
JSRI――间接跳转到子程序指令 
 
操作： 
 程序跳转到存储器指定的子程序位置 
R31 ← PC + 2，PC ← MEM[(PC + unsign_extend(offset << 2)) & 0xfffffffc] 
 
yufa:
 jsri  label 
 
说明： 
 子程序间接跳转，将子程序的返回地址（下一条指令的PC，即当前PC+2）保存在链接寄存器R31中，程序跳转到label所在的位置处执行，label由存储器加载得到。存储器地址根据PC加上左移2位的10位相对偏移量无符号扩展到32位后的值得到。JSRI指令的跳转范围是全部4GB地址空间。 
 
影响标志位： 
 无影响 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 00100 
 Offset 
 

 
LD.B――无符号扩展字节加载指令 
 
操作： 
 从存储器加载字节到寄存器，无符号扩展 
RZ ← zero_extend(MEM[RX + sign_extend(offset)]) 
 
yufa:
 ld.b  rz, (rx, offset) 
 
说明： 
 从存储器加载的字节经零扩展到32位后存放于寄存器RZ中。采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上2位相对偏移量无符号扩展到32位后的值得到。LD.B指令可以寻址+4B的地址空间。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 10000 
 RZ 
 RX 
 Offset 
 

 
LD.H――无符号扩展半字加载指令 
 
操作： 
 从存储器加载半字到寄存器，无符号扩展 
RZ ← zero_extend(MEM[RX + sign_extend(offset << 1)]) 
 
yufa:
 ld.h  rz, (rx, offset) 
 
说明： 
 从存储器加载的字节经零扩展到32位后存放于寄存器RZ中。采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移1位的2位相对偏移量无符号扩展到32位后的值得到。LD.H指令可以寻址+8B的地址空间。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 10001 
 RZ 
 RX 
 Offset 
 

 
LD.W――字加载指令 
 
操作： 
 从存储器加载字到寄存器，无符号扩展 
RZ ← zero_extend(MEM[RX + sign_extend(offset << 2)]) 
 
yufa:
 ld.w  rz, (rx, offset) 
 
说明： 
 从存储器加载字到寄存器RZ中。采用寄存器加立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移2位的2位相对偏移量无符号扩展到32位后的值得到。LD.W指令可以寻址+16B的地址空间。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 10010 
 RZ 
 RX 
 Offset 
 

 
LDM――连续多字加载指令 
 
操作： 
 从存储器加载连续的多个字到一片连续的寄存器堆中 
dst ← Z C IMM2; addr ← RX; 
for (n = 0; n <= IMM2; n++){ 
  Rdst ← MEM[addr]; 
  dst ← dst + 1; 
  addr ← addr + 4; 
} 
 
yufa:
 ldm  ry-rz, rx 
 
说明： 
 从存储器依次加载连续的多个字到寄存器RY开始的一片连续的寄存器堆中，即将存储器指定地址开始的第一个字加载到寄存器RY中，第二个字加载到寄存器RY+1中，依次类推，最后一个字加载到寄存器RZ中。存储器的有效地址由基址寄存器RX的内容决定。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15；RY-RZ范围内不应该包含基址寄存器RX，否则结果不可预测。 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 10011 
 RZ 
 RX 
 IMM2 
 

 
IMM2域――指定目标寄存器的个数，IMM2 = Z - Y。 
00――1个目的寄存器 
01――2个目的寄存器 
10――3个目的寄存器 
11――4个目的寄存器 
 
LSL――逻辑左移指令 
 
操作： 
 RZ ← RZ << RX[5:0] 
 
yufa:
 lsl  rz, rx 
 
说明： 
 将RZ的值进行逻辑左移（原值左移，右侧移入0），结果存入RZ，左移位数由RX低6位（RX[5:0]）的值确定；如果RX[5:0]的值大于31，那么RZ将被清零。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11100 
 RZ 
 RX 
 00 
 

 
LSLI――立即数逻辑左移指令 
 
操作： 
 RZ ← RZ << IMM5 
 
yufa:
 lsli  rz, imm5 
 
说明： 
 将RZ的值进行逻辑左移（原值左移，右侧移入0），结果存入RZ，左移位数由5位立即数（IMM5）的值决定；如果IMM5的值等于0，那么RZ的值将不变。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01011 
 RZ 
 IMM5 
 0 
 

 
LSR――逻辑右移指令 
 
操作： 
 RZ ← RZ >> RX[5:0] 
 
yufa:
 lsr  rz, rx 
 
说明： 
 将RZ的值进行逻辑右移（原值右移，左侧移入0），结果存入RZ，右移位数由RX低6位（RX[5:0]）的值确定；如果RX[5:0]的值大于31，那么RZ将被清零。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11100 
 RZ 
 RX 
 01 
 

 
LSRI――立即数逻辑右移指令 
 
操作： 
 RZ ← RZ >> IMM5 
 
yufa:
 lsri  rz, imm5 
 
说明： 
 将RZ的值进行逻辑右移（原值右移，左侧移入0），结果存入RZ，右移位数由5位立即数（IMM5）的值决定；如果IMM5的值等于0，那么RZ的值将不变。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01011 
 RZ 
 IMM5 
 1 
 

 
MOV――数据传送指令 
 
操作： 
 RZ ← RX 
 
yufa:
 mov  rz, rx 
 
说明： 
 把RX中的值复制到目的寄存器RZ中。 
注意，该指令寄存器索引范围为r0-r31。 
 
影响标志位： 
 无影响 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 00111 
 RZ 
 RX 
 Z 
 X 
 

 
Z，X域――与RZ，RX共同索引寄存器。 
{Z:RZ}――指定目的寄存器 
{X:RX}――指定源寄存器 
 
MOVI――立即数数据传送指令 
 
操作： 
 RZ ← zero_extend(IMM5); 
 
yufa:
 movi  rz, imm5 
 
说明： 
 将5位立即数零扩展至32位，然后传送至目的RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01110 
 RZ 
 IMM5 
 0 
 

 
MULSH――16位有符号乘法指令 
 
操作： 
 两个16位有符号数相乘，结果放入通用寄存器中 
RZ ← RX[15..0] × RZ[15..0] 
 
yufa:
 mulsh  rz, rx 
 
说明： 
 将通用寄存器RX的低16位和RZ的低16位相乘后得到的32位结果存放到通用寄存器RZ中。寄存器RX和RZ的内容均被认为是有符号数，其中源操作数的符号位是寄存器的第15位，结果的符号位是寄存器的第31位。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11111 
 RZ 
 RX 
 00 
 

 
MULT――乘法指令 
 
操作： 
 两个数相乘，结果的低32位放入通用寄存器中 
RZ ← RX × RZ 
 
yufa:
 mult  rz, rx 
 
说明： 
 将通用寄存器RX和RZ的内容相乘后得到结果的低32位存放到通用寄存器RZ中，结果的高32位舍弃。不管源操作数被认为是有符号数还是无符号数，结果都相同。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11111 
 RZ 
 RX 
 01 
 

MVC――C位传送指令 
 
操作： 
 RZ ← C 
 
yufa:
 mvc  rz 
 
说明： 
 把条件位C传送到RZ的最低位，RZ的其它位清零。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11110 
 RZ 
 0000 
 00 
 

 
NOR――按位或非指令 
 
操作： 
 RZ ← !(RZ | RX) 
 
yufa:
 nor  rz, rx 
 
说明： 
 将RZ与RX的值按位或，然后按位取非，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11011 
 RZ 
 RX 
 10 
 

 
OR――按位或指令 
 
操作： 
 RZ ← RZ | RX 
 
yufa:
 or  rz, rx 
 
说明： 
 将RZ与RX的值按位或，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11011 
 RZ 
 RX 
 00 
 

 
REVB――字节倒序指令 
 
操作： 
 RZ[31:24]  ←  RX[7:0]; 
RZ[23:16]  ←  RX[15:8]; 
RZ[15:8]   ←  RX[23:16]; 
RZ[7:0]    ←  RX[31:24]; 
 
yufa:
 revb  rz, rx 
 
说明： 
 把RX的值按字节取倒序，各字节内部的位顺序保持不变，结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11110 
 RZ 
 RX 
 10 
 

 
REVH――半字内字节倒序指令 
 
操作： 
 RZ[31:24]  ←  RX[23:16]; 
RZ[23:16]  ←  RX[31:24]; 
RZ[15:8]   ←  RX[7:0]; 
RZ[7:0]    ←  RX[15:8]; 
 
yufa:
 revb  rz, rx 
 
说明： 
 把RX的值在半字内按字节取倒序，即分别交换高半字内的两个字节和低半字内的两个字节，两个半字间的顺序和各字节内的位顺序保持不变，结果存入RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11110 
 RZ 
 RX 
 11 
 

 
ROTL――循环左移指令 
 
操作： 
 RZ ← RZ <<<< RX[5:0] 
 
yufa:
 rotl  rz, rx 
 
说明： 
 将RZ的值进行循环左移（原值左移，右侧移入左侧移出的位），结果存入RZ，左移位数由RX低6位（RX[5:0]）的值决定；如果RX[5:0]的值等于32，那么RZ的值将不变。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11100 
 RZ 
 RX 
 11 
 

 
ROTLI――立即数循环左移指令 
 
操作： 
 RZ ← RZ <<<< IMM5 
 
yufa:
 rotli  rz, imm5 
 
说明： 
 将RZ的值进行循环左移（原值左移，右侧移入左侧移出的位），结果存入RZ，左移位数由5位立即数（IMM5）的值决定；如果IMM5的值等于0，那么RZ的值将不变。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为0-31。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01100 
 RZ 
 IMM5 
 1 
 

 
SEXTB――字节提取并有符号扩展指令 
 
操作： 
 RZ ← sign_extend(RX[7:0]); 
 
yufa:
 sextb  rz, rx 
 
说明： 
 将RX的低字节（RX[7:0]）符号扩展至32位，结果存在RZ中。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11101 
 RZ 
 RX 
 10 
 

 
SEXTH――半字提取并有符号扩展指令 
 
操作： 
 RZ ← sign_extend(RX[15:0]); 
 
yufa:
 sextb  rz, rx 
 
说明： 
 将RX的低半字（RX[15:0]）符号扩展至32位，结果存在RZ中。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11101 
 RZ 
 RX 
 11 
 

 
ST.B――字节存储指令 
 
操作： 
 将寄存器中的最低字节存储到存储器中 
MEM[RX + unsign_extend(offset)] ← RZ[7:0] 
 
yufa:
 st.b  rz, (rx, offset) 
 
说明： 
 将寄存器RZ中的最低字节存储到存储器中。采用寄存器加无符号立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上2位相对偏移量无符号扩展到32位后的值得到。ST.B指令可以寻址+4B的空间。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 10100 
 RZ 
 RX 
 Offset 
 

 
ST.H――半字存储指令 
 
操作： 
 将寄存器中的低半字存储到存储器中 
MEM[RX + unsign_extend(offset << 1)] ← RZ[15:0] 
 
yufa:
 st.h  rz, (rx, offset) 
 
说明： 
 将寄存器RZ中的低半字存储到存储器中。采用寄存器加无符号立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移1位的2位相对偏移量无符号扩展到32位后的值得到。ST.H指令可以寻址+8B的空间。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 10101 
 RZ 
 RX 
 Offset 
 

 
ST.W――字存储指令 
 
操作： 
 将寄存器中的字存储到存储器中 
MEM[RX + unsign_extend(offset << 2)] ← RZ[31:0] 
 
yufa:
 st.w  rz, (rx, offset) 
 
说明： 
 将寄存器RZ中的字存储到存储器中。采用寄存器加无符号立即数偏移量的寻址方式。存储器的有效地址由基址寄存器RX加上左移两位的2位相对偏移量无符号扩展到32位后的值得到。ST.W指令可以寻址+16B的空间。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 10110 
 RZ 
 RX 
 Offset 
 

 
STM――连续多字存储指令 
 
操作： 
 将一片连续的寄存器堆中内容依次存储到一片连续的存储器地址上。dst ← Z C IMM2; addr ← RX; 
for (n = 0; n <= IMM2; n++){ 
  MEM[addr] ← Rdst; 
  dst ← dst + 1; 
  addr ← addr + 4; 
} 
 
yufa:
 ldm  ry-rz, rx 
 
说明： 
 将从寄存器RY开始的一片连续的寄存器堆中的内容依次存储到一片连续的存储器地址上，即将寄存器RY的内容存到存储器指定地址开始的第一个字的地址上，寄存器RY+1的内容存到存储器指定地址开始的第二个字的地址上，依次类推，将寄存器RZ的内容存到存储器指定地址开始的最后一个字的地址上。存储器的有效地址由基址寄存器RX的内容决定。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 未对齐访问异常、访问错误异常、TLB不可恢复异常、TLB失配异常、TLB读无效异常 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 10111 
 RZ 
 RX 
 IMM2 
 

 
IMM2域――指定目标寄存器的个数，IMM2 = Z - Y。 
00――1个目的寄存器 
01――2个目的寄存器 
10――3个目的寄存器 
11――4个目的寄存器 
 
SUBC――无符号带借位减法指令 
 
操作： 
 RZ ← RZ - RX -（!C），C ← 借位 
 
yufa:
 subc  rz, rx 
 
说明： 
 将RZ的值减去寄存器RX的值和C位的非值，并把结果存在RZ，借位存在C位。对于该减法指令来说，如果发生借位，将清C位，反之置C位。 
 
影响标志位： 
 C ← 借位 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11000 
 RZ 
 RX 
 11 
 

 
SUBI――无符号立即数减法指令 
 
操作： 
 RZ ← RZ - zero_extend(OIMM5) 
 
yufa:
 subi  rz, oimm5 
 
说明： 
 将带偏置1的5位立即数（OIMM5）零扩展至32位，然后用RZ的值减去该32位数，把结果存入RZ。 
注意：二进制操作数IMM5等于OIMM5 - 1。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15； 
立即数的范围为1-32。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 1 
 0 
 
1 
 01000 
 RZ 
 IMM5 
 1 
 

 
IMM5域――指定不带偏置立即数的值。 
注意：寄存器减去的值OIMM5比起二进制操作数IMM5需偏置1。 
00000――减1 
00001――减2 
…… 
11111――减32 
 
SUBU――无符号减法指令 
 
操作： 
 RZ ← RZ - RX 
 
yufa:
 subu  rz, rx 
sub   rz, rx 
 
说明： 
 将RZ的值减去RX值，并把结果存在RZ中。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11000 
 RZ 
 RX 
 10 
 

 
 
TST――零测试指令 
 
操作： 
 If (RX & RY) != 0, then 
C ← 1; 
else 
  C ← 0; 
 
yufa:
 tst  rx, ry 
 
说明： 
 测试RX和RY的值按位与的结果。 
如果结果不等于0，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 根据按位与结果设置条件位C 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11010 
 RY 
 RX 
 10 
 

 
TSTNBZ――无字节等于零寄存器测试指令 
 
操作： 
 If  ( (RX[31:24] != 0) 
&(RX[23:16] != 0) 
&(RX[15: 8 ] != 0) 
&(RX[ 7 : 0 ] != 0) ), then 
C ← 1; 
else 
  C ← 0; 
 
yufa:
 tstnbz  rx 
 
说明： 
 测试RX中是否没有字节等于零。如果RX没有字节等于零，则设置条件位C；否则，清除条件位C。 
 
影响标志位： 
 如果RX没有字节等于零，则设置条件位C；否则，清除条件位C。 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11010 
 0000 
 RX 
 11 
 

 
XOR――按位异或指令 
 
操作： 
 RZ ← RZ ^ RX 
 
yufa:
 xor  rz, rx 
 
说明： 
 将RZ与RX的值按位异或，并把结果存在RZ。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11011 
 RZ 
 RX 
 01 
 

 
ZEXTB――字节提取并无符号扩展指令 
 
操作： 
 RZ ← zero_extend(RX[7:0]); 
 
yufa:
 zextb  rz, rx 
 
说明： 
 将RX的低字节（RX[7:0]）零扩展至32位，结果存在RZ中。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11101 
 RZ 
 RX 
 00 
 

 
ZEXTH――半字提取并无符号扩展指令 
 
操作： 
 RZ ← zero_extend(RX[15:0]); 
 
yufa:
 zextb  rz, rx 
 
说明： 
 将RX的低半字（RX[15:0]）零扩展至32位，结果存在RZ中。 
 
影响标志位： 
 无影响 
 
限制： 
 寄存器的范围为r0-r15。 
 
异常： 
 无 
 
指令格式： 
  
 

 
15 
 14 
  
 10 
 9 
  
 6 
 5 
  
 2 
 1 
 0 
 
1 
 11101 
 RZ 
 RX 
 01 
 

 
 

